<!doctype html>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Snakes & Ladders</title>
    <meta
      name="description"
      content="A one-page Snakes & Ladders video game. Roll the die, climb ladders, avoid snakes, and race to 100."
    />
    <title>LeNard’s board game</title>
    <style>
      :root {
        --bg0: #070a12;
        --bg1: #0b1220;
        --card: rgba(255, 255, 255, 0.06);
        --card2: rgba(255, 255, 255, 0.09);
        --stroke: rgba(255, 255, 255, 0.12);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.68);
        --muted2: rgba(255, 255, 255, 0.55);
        --shadow: 0 18px 45px rgba(0, 0, 0, 0.45);
        --shadow2: 0 10px 25px rgba(0, 0, 0, 0.32);
        --radius: 16px;
        --radius2: 12px;
        --accent: #7c3aed; /* violet */
        --accent2: #22c55e; /* green */
        --danger: #ef4444; /* red */
        --warn: #f59e0b;
        --good: #10b981;
        --outside: #0b0d10;
        --outside2: #07080a;
        --board: #5b0f14; /* deep red */
        --board2: #4a0d11;
        --ink: rgba(244, 241, 234, 0.9);
        --ink2: rgba(244, 241, 234, 0.7);
        --ink3: rgba(244, 241, 234, 0.5);
        --grid: rgba(0, 0, 0, 0.25);
        --shadow: rgba(0, 0, 0, 0.55);
        --wood: rgba(144, 98, 62, 0.92);
        --woodDark: rgba(58, 35, 18, 0.55);
        --moss: rgba(33, 120, 58, 0.55);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        color: var(--text);
        background:
          radial-gradient(1200px 600px at 20% -10%, rgba(124, 58, 237, 0.32), transparent 60%),
          radial-gradient(1000px 700px at 90% 10%, rgba(34, 197, 94, 0.18), transparent 55%),
          radial-gradient(900px 600px at 40% 115%, rgba(59, 130, 246, 0.12), transparent 60%),
          linear-gradient(180deg, var(--bg0), var(--bg1));
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
          "Apple Color Emoji", "Segoe UI Emoji";
        line-height: 1.25;
          radial-gradient(1200px 650px at 20% 10%, rgba(120, 140, 160, 0.08), transparent 55%),
          radial-gradient(1000px 650px at 85% 15%, rgba(90, 100, 80, 0.06), transparent 55%),
          linear-gradient(180deg, var(--outside), var(--outside2));
        color: var(--ink);
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        opacity: 0.5;
        background:
          radial-gradient(circle at 25% 30%, rgba(255, 255, 255, 0.03), transparent 55%),
          radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.02), transparent 60%),
          repeating-linear-gradient(
            112deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 9px
          );
      }

      a {
        color: inherit;
        text-decoration: none;
        text-decoration: underline;
        text-decoration-style: dotted;
        text-underline-offset: 4px;
      }

      .page {
      .view {
        display: none;
        min-height: 100%;
        display: grid;
        grid-template-rows: auto 1fr auto;
      }

      header {
        padding: 28px 18px 10px;
        max-width: 1100px;
        margin: 0 auto;
        width: 100%;
      .view.active {
        display: block;
      }

      .titleRow {
        display: flex;
        gap: 16px;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
      .shell {
        width: min(1480px, calc(100vw - 24px));
        margin: 0 auto;
        padding: 14px 0 18px;
      }

      .brand {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .logo {
        width: 46px;
        height: 46px;
        border-radius: 14px;
        background:
          radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.24), transparent 60%),
          linear-gradient(135deg, rgba(124, 58, 237, 1), rgba(34, 197, 94, 1));
        box-shadow: var(--shadow2);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      h1 {
        margin: 0;
        font-size: 22px;
      .title {
        font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
        font-size: 20px;
        font-weight: 500;
        letter-spacing: 0.2px;
        text-align: center;
        margin: 6px 0 14px;
        color: rgba(244, 241, 234, 0.86);
      }

      .subtitle {
        margin: 3px 0 0;
        color: var(--muted);
        font-size: 13px;
      }

      .topActions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      main {
        max-width: 1100px;
        margin: 0 auto;
        width: 100%;
        padding: 14px 18px 28px;
      .stage {
        display: grid;
        grid-template-columns: 1.15fr 0.85fr;
        gap: 18px;
        grid-template-columns: 4fr 1fr; /* ~80% / ~20% */
        gap: 14px;
        align-items: start;
      }

      @media (max-width: 980px) {
        main {
      @media (max-width: 900px) {
        .stage {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: var(--card);
        border: 1px solid var(--stroke);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
      .boardArea {
        min-width: 0;
      }

      .boardCard {
        padding: 14px;
      }

      .boardTop {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 12px;
        padding: 2px 2px 12px;
      }

      .boardTop .hint {
        color: var(--muted);
        font-size: 13px;
      }

      .boardWrap {
      .board {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: calc(var(--radius) - 6px);
        background: var(--board);
        border-radius: 16px;
        overflow: hidden;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.02));
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow:
          0 22px 55px var(--shadow),
          inset 0 0 0 2px rgba(0, 0, 0, 0.22),
          inset 0 0 0 7px rgba(255, 255, 255, 0.05);
        transform: rotate(-0.35deg);
      }

      /* Grid is for numbers / squares; canvas draws snakes & ladders; token floats above */
      .boardGrid {
      /* cardboard / print imperfections */
      .board::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0.92;
        background:
          radial-gradient(circle at 18% 22%, rgba(255, 255, 255, 0.06), transparent 55%),
          radial-gradient(circle at 78% 68%, rgba(0, 0, 0, 0.16), transparent 60%),
          repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 7px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(0, 0, 0, 0.03),
            rgba(0, 0, 0, 0.03) 1px,
            transparent 1px,
            transparent 9px
          );
        mix-blend-mode: overlay;
      }

      .board::after {
        content: "";
        position: absolute;
        inset: -1px;
        pointer-events: none;
        opacity: 0.9;
        background: radial-gradient(circle at 50% 50%, transparent 58%, rgba(0, 0, 0, 0.22) 95%);
      }

      .grid {
        position: absolute;
        inset: 14px;
        border-radius: 12px;
        overflow: hidden;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.22);
      }

      .cell {
        position: relative;
        padding: 8px;
        border-right: 1px solid rgba(255, 255, 255, 0.08);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        user-select: none;
        border-right: 1px solid rgba(0, 0, 0, 0.22);
        border-bottom: 1px solid rgba(0, 0, 0, 0.22);
        background:
          radial-gradient(circle at 24% 20%, rgba(255, 255, 255, 0.06), transparent 62%),
          radial-gradient(circle at 70% 78%, rgba(0, 0, 0, 0.1), transparent 65%);
      }

      .cell:nth-child(10n) {
        border-right: none;
      .cell::before {
        content: "";
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 20% 25%, rgba(255, 255, 255, 0.07), transparent 55%);
        opacity: 0.8;
        pointer-events: none;
        opacity: 0.65;
        background:
          radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.035), transparent 55%),
          radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.06), transparent 55%);
      }

      .cellNum {
      .num {
        position: absolute;
        top: 7px;
        left: 8px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.72);
        font-variant-numeric: tabular-nums;
        top: 6px;
        left: 7px;
        font-size: 9px;
        letter-spacing: 0.2px;
        color: rgba(255, 255, 255, 0.36);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        user-select: none;
        text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
      }

      .cellBadges {
      canvas.paths {
        position: absolute;
        bottom: 7px;
        left: 8px;
        right: 8px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
      }

      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 7px;
        border-radius: 999px;
        font-size: 11px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        color: rgba(255, 255, 255, 0.8);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.25);
      }

      .badge.ladder {
        border-color: rgba(34, 197, 94, 0.35);
        background: rgba(34, 197, 94, 0.12);
      }
      .badge.snake {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(239, 68, 68, 0.12);
      }

      canvas#paths {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        inset: 14px;
        width: calc(100% - 28px);
        height: calc(100% - 28px);
        pointer-events: none;
      }

      .tokenLayer {
      .pieces {
        position: absolute;
        inset: 0;
        inset: 14px;
        pointer-events: none;
      }

      .token {
      .piece {
        position: absolute;
        width: 18px;
        height: 18px;
        border-radius: 999px;
        width: 30px;
        height: 30px;
        transform: translate(-50%, -50%);
        background:
          radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.95), rgba(255, 255, 255, 0.35) 35%, rgba(124, 58, 237, 1) 75%);
        border: 1px solid rgba(255, 255, 255, 0.28);
        box-shadow: 0 14px 30px rgba(124, 58, 237, 0.28);
        filter:
          drop-shadow(0 10px 16px rgba(0, 0, 0, 0.35))
          drop-shadow(0 2px 0 rgba(255, 255, 255, 0.08));
        opacity: 0.98;
      }

      .token::after {
        content: "";
        position: absolute;
        inset: -6px;
        border-radius: 999px;
        background: radial-gradient(circle, rgba(124, 58, 237, 0.22), transparent 65%);
        filter: blur(1px);
      .piece svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .sideCard {
        padding: 14px;
        display: grid;
        gap: 12px;
        align-content: start;
      .side {
        min-width: 0;
        padding-top: 8px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        color: rgba(244, 241, 234, 0.82);
      }

      .panelTitle {
      .row {
        display: flex;
        align-items: baseline;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 2px 2px 2px;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(244, 241, 234, 0.14);
      }

      .panelTitle h2 {
        margin: 0;
        font-size: 15px;
        letter-spacing: 0.2px;
      .row:last-child {
        border-bottom: none;
      }

      .panelTitle .small {
        color: var(--muted2);
        font-size: 12px;
      .label {
        color: rgba(244, 241, 234, 0.62);
      }

      .stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      .value {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        color: rgba(244, 241, 234, 0.86);
      }

      .stat {
        padding: 12px;
        border-radius: var(--radius2);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.05);
      }

      .stat .label {
        color: var(--muted2);
        font-size: 11px;
      }
      .stat .value {
        margin-top: 6px;
        font-size: 18px;
        font-variant-numeric: tabular-nums;
      }

      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }

      button {
        appearance: none;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        padding: 10px 12px;
        background: rgba(244, 241, 234, 0.06);
        border: 1px solid rgba(244, 241, 234, 0.16);
        color: rgba(244, 241, 234, 0.88);
        padding: 10px 10px;
        border-radius: 12px;
        font-weight: 650;
        font-size: 13px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        letter-spacing: 0.2px;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
        transition: transform 120ms ease, background 120ms ease;
      }

      button:hover {
        background: rgba(244, 241, 234, 0.1);
        transform: translateY(-1px);
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.26);
      }

      button:active {
        transform: translateY(0px);
      }

      button.primary {
        background: linear-gradient(135deg, rgba(124, 58, 237, 0.95), rgba(34, 197, 94, 0.8));
        border-color: rgba(255, 255, 255, 0.22);
      }

      button.primary:hover {
        background: linear-gradient(135deg, rgba(124, 58, 237, 1), rgba(34, 197, 94, 0.92));
      }

      button.danger {
        background: rgba(239, 68, 68, 0.12);
        border-color: rgba(239, 68, 68, 0.35);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
      }

      .log {
        padding: 12px;
        border-radius: var(--radius2);
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        min-height: 160px;
        max-height: 260px;
        margin-top: 12px;
        padding-top: 8px;
        max-height: 72px;
        overflow: auto;
        font-size: 13px;
        color: rgba(255, 255, 255, 0.82);
        color: rgba(244, 241, 234, 0.7);
      }

      .log p {
        margin: 0 0 8px 0;
        margin: 0 0 6px 0;
      }

      .log p:last-child {
        margin-bottom: 0;
      .setup {
        margin: 12px auto 0;
        width: min(520px, calc(100vw - 24px));
        padding: 16px 14px;
        border: 1px solid rgba(244, 241, 234, 0.14);
        border-radius: 16px;
        background: rgba(244, 241, 234, 0.04);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        color: rgba(244, 241, 234, 0.86);
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        font-variant-numeric: tabular-nums;
      .setup h2 {
        margin: 0 0 10px 0;
        font-size: 14px;
        font-weight: 650;
      }

      .pill {
        display: inline-flex;
      .setup .choices {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 7px 10px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(255, 255, 255, 0.06);
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.85);
        font-size: 12px;
      }

      .kbd {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        font-size: 11px;
        padding: 1px 6px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.25);
        color: rgba(255, 255, 255, 0.85);
      }

      footer {
        padding: 18px;
        color: rgba(255, 255, 255, 0.55);
      .note {
        margin-top: 10px;
        color: rgba(244, 241, 234, 0.62);
        font-size: 12px;
        text-align: center;
        line-height: 1.25;
      }

      .srOnly {
        position: absolute;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .toast {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        padding: 12px 14px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.16);
        background: rgba(0, 0, 0, 0.55);
        color: rgba(255, 255, 255, 0.9);
        box-shadow: var(--shadow);
        backdrop-filter: blur(10px);
        max-width: min(680px, calc(100vw - 26px));
        display: none;
        z-index: 30;
      }

      .toast.show {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="page">
      <header>
        <div class="titleRow">
          <div class="brand">
            <div class="logo" aria-hidden="true"></div>
            <div>
              <h1>Snakes & Ladders</h1>
              <p class="subtitle">A one-page video game. Roll, climb, slide, and reach 100.</p>
            </div>
          </div>
          <div class="topActions">
            <span class="pill" title="Keyboard shortcuts">
              <span class="mono">Shortcuts</span>
              <span class="kbd">Space</span>
              <span class="mono">roll</span>
              <span class="kbd">R</span>
              <span class="mono">reset</span>
            </span>
          </div>
        </div>
      </header>
    <!-- piece art (metallic) -->
    <svg class="srOnly" aria-hidden="true">
      <defs>
        <linearGradient id="silverGrad" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#fbfbfb" stop-opacity="0.98" />
          <stop offset="0.23" stop-color="#d7d7d7" stop-opacity="0.98" />
          <stop offset="0.52" stop-color="#bdbdbd" stop-opacity="0.98" />
          <stop offset="0.78" stop-color="#f2f2f2" stop-opacity="0.98" />
          <stop offset="1" stop-color="#9f9f9f" stop-opacity="0.98" />
        </linearGradient>
        <filter id="metalRough" x="-20%" y="-20%" width="140%" height="140%">
          <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="11" />
          <feColorMatrix type="matrix" values="
            1 0 0 0 0
            0 1 0 0 0
            0 0 1 0 0
            0 0 0 0.16 0" />
          <feComposite operator="in" in2="SourceGraphic" />
          <feBlend mode="overlay" in2="SourceGraphic" />
        </filter>

      <main>
        <section class="card boardCard" aria-label="Game board">
          <div class="boardTop">
            <div>
              <div class="mono" style="font-weight: 750; letter-spacing: 0.2px">Board</div>
              <div class="hint">Start at 1. Exact roll to land on 100 wins.</div>
            </div>
            <div class="mono" style="color: rgba(255, 255, 255, 0.75); font-size: 12px">
              Snakes: <span id="snakeCount">—</span> · Ladders: <span id="ladderCount">—</span>
            </div>
          </div>
        <symbol id="p-shoe" viewBox="0 0 64 64">
          <path
            d="M10 40c6 0 10-6 14-14 3-7 7-10 12-10 4 0 6 3 8 6 2 4 4 7 9 9 4 2 7 4 7 8 0 6-6 9-16 9H18c-8 0-12-3-12-8 0-3 2-6 4-6z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M16 41c9 2 20 2 32 0"
            stroke="rgba(0,0,0,0.22)"
            stroke-width="1.2"
            stroke-linecap="round"
            opacity="0.55"
          />
        </symbol>

          <div class="boardWrap" id="boardWrap">
            <canvas id="paths" width="1000" height="1000" aria-hidden="true"></canvas>
            <div class="boardGrid" id="boardGrid" aria-hidden="true"></div>
            <div class="tokenLayer" aria-hidden="true">
              <div class="token" id="token"></div>
            </div>
          </div>
        </section>
        <symbol id="p-hat" viewBox="0 0 64 64">
          <path
            d="M30 10c10 10 16 22 16 30 0 7-6 10-14 10-7 0-14-3-14-10 0-9 4-18 12-30z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M10 44c8 5 36 5 44 0"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
        </symbol>

        <aside class="card sideCard" aria-label="Game controls">
          <div class="panelTitle">
            <h2>Controls</h2>
            <div class="small">Single-player</div>
          </div>
        <symbol id="p-dog" viewBox="0 0 64 64">
          <path
            d="M18 44c0-10 7-18 16-18 7 0 12 4 14 9 3 0 6 2 6 6 0 5-4 8-9 8-1 5-6 9-13 9-9 0-14-6-14-14z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M23 33c-3-2-6-5-6-9 0-5 5-7 9-5"
            fill="none"
            stroke="rgba(0,0,0,0.24)"
            stroke-width="1.3"
            stroke-linecap="round"
            opacity="0.6"
          />
        </symbol>
      </defs>
    </svg>

          <div class="stats" role="group" aria-label="Current status">
            <div class="stat">
              <div class="label">Position</div>
              <div class="value mono"><span id="pos">1</span> / 100</div>
    <section class="view active" id="view-single" aria-label="Single player">
      <div class="shell">
        <div class="title">LeNard’s board game</div>
        <div class="stage">
          <div class="boardArea">
            <div class="board" id="single-board">
              <canvas class="paths" id="single-canvas" aria-hidden="true"></canvas>
              <div class="grid" id="single-grid" aria-hidden="true"></div>
              <div class="pieces" id="single-pieces" aria-hidden="true"></div>
            </div>
            <div class="stat">
              <div class="label">Last roll</div>
              <div class="value mono"><span id="lastRoll">—</span></div>
          </div>
          <aside class="side" aria-label="Controls">
            <div class="row">
              <div class="label">Turn</div>
              <div class="value" id="single-turn">1</div>
            </div>
            <div class="stat">
              <div class="label">Turns</div>
              <div class="value mono"><span id="turns">0</span></div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="single-pos">1</div>
            </div>
            <div class="stat">
              <div class="label">Status</div>
              <div class="value"><span id="statusText">Ready</span></div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="single-last">—</div>
            </div>
          </div>
            <div class="row">
              <div class="label">Piece</div>
              <div class="value" id="single-piece">—</div>
            </div>
            <div class="controls">
              <button id="single-roll" type="button">Roll</button>
              <button id="single-new" type="button">New board</button>
              <button id="single-reset" type="button">Reset</button>
            </div>
            <div style="margin-top: 10px; color: rgba(244, 241, 234, 0.62)">
              <a href="#multiplayer">Multiplayer</a>
            </div>
            <div class="log" id="single-log" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

          <div class="controls">
            <button class="primary" id="rollBtn" type="button">Roll die</button>
            <button id="newBoardBtn" type="button" title="Generate new snakes & ladders">
              New board
            </button>
            <button class="danger" id="resetBtn" type="button">Reset run</button>
          </div>
    <section class="view" id="view-multi" aria-label="Multiplayer">
      <div class="shell">
        <div class="title">LeNard’s board game</div>

          <div class="panelTitle" style="margin-top: 2px">
            <h2>Game log</h2>
            <div class="small">Most recent on top</div>
        <div class="setup" id="multi-setup">
          <h2>Multiplayer</h2>
          <div class="choices" role="group" aria-label="Choose number of players">
            <button id="multi-2" type="button">2 players</button>
            <button id="multi-3" type="button">3 players</button>
          </div>
          <div class="log" id="log" aria-live="polite"></div>
          <div class="note">
            Each player gets a little silver thing.
            <div style="margin-top: 8px"><a href="#single">Back to single-player</a></div>
          </div>
        </div>

          <div class="panelTitle">
            <h2>Rules</h2>
            <div class="small">Quick</div>
        <div class="stage" id="multi-stage" style="display: none">
          <div class="boardArea">
            <div class="board" id="multi-board">
              <canvas class="paths" id="multi-canvas" aria-hidden="true"></canvas>
              <div class="grid" id="multi-grid" aria-hidden="true"></div>
              <div class="pieces" id="multi-pieces" aria-hidden="true"></div>
            </div>
          </div>
          <div style="color: rgba(255, 255, 255, 0.74); font-size: 13px; padding: 0 2px 4px">
            - Roll 1–6 and move forward.<br />
            - Land on a <span style="color: rgba(34, 197, 94, 0.95)">ladder</span> to climb up.<br />
            - Land on a <span style="color: rgba(239, 68, 68, 0.95)">snake</span> to slide down.<br />
            - If a roll would pass 100, you don’t move.
          </div>
        </aside>
      </main>
          <aside class="side" aria-label="Controls">
            <div class="row">
              <div class="label">Player</div>
              <div class="value" id="multi-player">1</div>
            </div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="multi-pos">1</div>
            </div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="multi-last">—</div>
            </div>
            <div class="controls">
              <button id="multi-roll" type="button">Roll</button>
              <button id="multi-new" type="button">New board</button>
              <button id="multi-reset" type="button">Reset</button>
            </div>
            <div style="margin-top: 10px; color: rgba(244, 241, 234, 0.62)">
              <a href="#single">Single-player</a>
            </div>
            <div class="log" id="multi-log" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

      <footer>
        Built as a single HTML file — open `index.html` in any browser.
      </footer>
    </div>

    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <script>
      // Snakes & Ladders: one-page, no dependencies.
      // Board numbering is serpentine: bottom row 1..10 (left→right), next row 11..20 (right→left), ... top ends at 100.

      const $ = (id) => document.getElementById(id);
      const els = {
        boardWrap: $("boardWrap"),
        boardGrid: $("boardGrid"),
        canvas: $("paths"),
        token: $("token"),
        rollBtn: $("rollBtn"),
        resetBtn: $("resetBtn"),
        newBoardBtn: $("newBoardBtn"),
        pos: $("pos"),
        lastRoll: $("lastRoll"),
        turns: $("turns"),
        statusText: $("statusText"),
        log: $("log"),
        snakeCount: $("snakeCount"),
        ladderCount: $("ladderCount"),
        toast: $("toast"),
      };

      const state = {
        pos: 1,
        lastRoll: null,
        turns: 0,
        locked: false,
        finished: false,
        // mapping: start -> end
        snakes: new Map(),
        ladders: new Map(),
      };

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function rollDie() {
        return randInt(1, 6);
      function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
      }

      function coordForSquare(n) {
        // Returns normalized center coordinates in [0..1] for given square 1..100.
        // Row 0 is bottom row (squares 1..10).
        const idx = n - 1;
        const row = Math.floor(idx / 10); // 0..9 bottom→top
        const colInRow = idx % 10;
        const isReversed = row % 2 === 1;
        const col = isReversed ? 9 - colInRow : colInRow;

        const x = (col + 0.5) / 10;
        const y = 1 - (row + 0.5) / 10;
        return { x, y, row, col };
      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function pixelForSquare(n) {
        const rect = els.boardWrap.getBoundingClientRect();
        const { x, y } = coordForSquare(n);
        return {
          x: rect.width * x,
          y: rect.height * y,
      function mulberry32(seed) {
        let t = seed >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }

      function setTokenPosition(n, { animate = true } = {}) {
        const p = pixelForSquare(n);
        els.token.style.transition = animate ? "left 220ms ease, top 220ms ease" : "none";
        els.token.style.left = `${p.x}px`;
        els.token.style.top = `${p.y}px`;
      function seedPair(a, b) {
        return ((a * 73856093) ^ (b * 19349663) ^ 0x9e3779b9) >>> 0;
      }

      function clearLog() {
        els.log.innerHTML = "";
      function coordForSquare(n) {
        // Serpentine numbering: bottom row 1..10 left->right, next row right->left...
        const idx = n - 1;
        const row = Math.floor(idx / 10); // 0..9 bottom->top
        const colInRow = idx % 10;
        const rev = row % 2 === 1;
        const col = rev ? 9 - colInRow : colInRow;
        return { x: (col + 0.5) / 10, y: 1 - (row + 0.5) / 10 };
      }

      function logLine(text) {
        const p = document.createElement("p");
        p.textContent = text;
        els.log.prepend(p);
      }
      function buildGrid(gridEl) {
        gridEl.innerHTML = "";
        for (let visualRow = 9; visualRow >= 0; visualRow--) {
          for (let visualCol = 0; visualCol < 10; visualCol++) {
            const logicalRow = 9 - visualRow;
            const rev = logicalRow % 2 === 1;
            const colInRow = rev ? 9 - visualCol : visualCol;
            const n = logicalRow * 10 + colInRow + 1;

      let toastTimer = null;
      function toast(message) {
        els.toast.textContent = message;
        els.toast.classList.add("show");
        if (toastTimer) window.clearTimeout(toastTimer);
        toastTimer = window.setTimeout(() => {
          els.toast.classList.remove("show");
        }, 2200);
            const cell = document.createElement("div");
            cell.className = "cell";
            const num = document.createElement("div");
            num.className = "num";
            num.textContent = String(n);
            cell.appendChild(num);
            gridEl.appendChild(cell);
          }
        }
      }

      function updateStats() {
        els.pos.textContent = String(state.pos);
        els.lastRoll.textContent = state.lastRoll == null ? "—" : String(state.lastRoll);
        els.turns.textContent = String(state.turns);

        if (state.finished) els.statusText.textContent = "You win!";
        else if (state.locked) els.statusText.textContent = "Moving…";
        else els.statusText.textContent = "Ready";
      function offsetsForCount(count, radius) {
        if (count <= 1) return [{ x: 0, y: 0, s: 1 }];
        if (count === 2) {
          return [
            { x: -radius * 0.75, y: 0, s: 0.88 },
            { x: radius * 0.75, y: radius * 0.1, s: 0.88 },
          ];
        }
        return [
          { x: -radius * 0.65, y: radius * 0.35, s: 0.82 },
          { x: radius * 0.7, y: radius * 0.25, s: 0.82 },
          { x: radius * 0.05, y: -radius * 0.65, s: 0.82 },
        ];
      }

      function setButtonsEnabled(enabled) {
        els.rollBtn.disabled = !enabled;
        els.newBoardBtn.disabled = !enabled;
        els.resetBtn.disabled = !enabled;
      function createPiece(shape, label) {
        const el = document.createElement("div");
        el.className = "piece";
        el.innerHTML = `<svg viewBox="0 0 64 64" role="img" aria-label="${label}"><use href="#${shape}"></use></svg>`;
        return el;
      }

      function drawBoardNumbersAndBadges() {
        els.boardGrid.innerHTML = "";
      class BoardRenderer {
        constructor(boardEl, canvasEl) {
          this.boardEl = boardEl;
          this.canvasEl = canvasEl;
        }

        // We render cells in visual top-left → bottom-right order,
        // but label them with the serpentine numbers.
        for (let visualRow = 9; visualRow >= 0; visualRow--) {
          for (let visualCol = 0; visualCol < 10; visualCol++) {
            const cell = document.createElement("div");
            cell.className = "cell";
        resizeCanvas() {
          const rect = this.boardEl.getBoundingClientRect();
          const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
          this.canvasEl.width = Math.floor(rect.width * dpr);
          this.canvasEl.height = Math.floor(rect.height * dpr);
          const ctx = this.canvasEl.getContext("2d");
          if (!ctx) return null;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          return { ctx, rect };
        }

            // Convert visual position to square number
            const logicalRow = 9 - visualRow; // 0 bottom .. 9 top
            const isReversed = logicalRow % 2 === 1;
            const colInRow = isReversed ? 9 - visualCol : visualCol;
            const n = logicalRow * 10 + colInRow + 1;
        squareToPx(n, rect) {
          const inset = 14;
          const inner = {
            left: inset,
            top: inset,
            w: rect.width - inset * 2,
            h: rect.height - inset * 2,
          };
          const { x, y } = coordForSquare(n);
          return { x: inner.left + inner.w * x, y: inner.top + inner.h * y };
        }

            const num = document.createElement("div");
            num.className = "cellNum";
            num.textContent = String(n);
            cell.appendChild(num);
        draw(boardMap) {
          const res = this.resizeCanvas();
          if (!res) return;
          const { ctx, rect } = res;
          ctx.clearRect(0, 0, rect.width, rect.height);

            const badges = document.createElement("div");
            badges.className = "cellBadges";
          // gentle ink smudges (imperfection)
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          for (let i = 0; i < 14; i++) {
            const x = Math.random() * rect.width;
            const y = Math.random() * rect.height;
            const r = 16 + Math.random() * 28;
            ctx.beginPath();
            ctx.ellipse(x, y, r * 1.2, r, (Math.random() - 0.5) * 0.6, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

            if (state.ladders.has(n)) {
              const b = document.createElement("span");
              b.className = "badge ladder";
              b.textContent = `Ladder ↑${state.ladders.get(n)}`;
              badges.appendChild(b);
            }
            if (state.snakes.has(n)) {
              const b = document.createElement("span");
              b.className = "badge snake";
              b.textContent = `Snake ↓${state.snakes.get(n)}`;
              badges.appendChild(b);
            }
            cell.appendChild(badges);

            els.boardGrid.appendChild(cell);
          for (const [from, to] of boardMap.ladders.entries()) {
            this.drawLadder(ctx, rect, from, to);
          }
          for (const [from, to] of boardMap.snakes.entries()) {
            this.drawSnake(ctx, rect, from, to);
          }
        }
      }

      function drawPaths() {
        const canvas = els.canvas;
        const ctx = canvas.getContext("2d");
        if (!ctx) return;
        drawLadder(ctx, rect, from, to) {
          const rnd = mulberry32(seedPair(from, to) ^ 0x8f2a);
          const a = this.squareToPx(from, rect);
          const b = this.squareToPx(to, rect);
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy) || 1;
          const dir = { x: dx / len, y: dy / len };
          const nrm = { x: -dir.y, y: dir.x };

        // Match canvas internal resolution to on-screen size for crisp lines.
        const rect = els.boardWrap.getBoundingClientRect();
        const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          const rail = clamp(10 + rnd() * 6, 10, 16);
          const railW = clamp(4.5 + rnd() * 2.0, 4.5, 7.4);

        ctx.clearRect(0, 0, rect.width, rect.height);
          const wood = getComputedStyle(document.documentElement).getPropertyValue("--wood").trim() || "rgba(144, 98, 62, 0.92)";
          const woodDark = getComputedStyle(document.documentElement).getPropertyValue("--woodDark").trim() || "rgba(58, 35, 18, 0.55)";
          const moss = getComputedStyle(document.documentElement).getPropertyValue("--moss").trim() || "rgba(33, 120, 58, 0.55)";

        function drawConnection(from, to, kind) {
          const a = pixelForSquare(from);
          const b = pixelForSquare(to);
          const jitter = (t) => (rnd() - 0.5) * t;

          // Control points for a smooth curve (slight sideways bend).
          // rails (slightly bowed old wood)
          for (const side of [-1, 1]) {
            const ox = nrm.x * rail * side;
            const oy = nrm.y * rail * side;
            const mid = {
              x: (a.x + b.x) / 2 + nrm.x * (rnd() - 0.5) * 18,
              y: (a.y + b.y) / 2 + nrm.y * (rnd() - 0.5) * 18,
            };

            ctx.save();
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.shadowColor = "rgba(0,0,0,0.25)";
            ctx.shadowBlur = 10;
            ctx.lineWidth = railW;
            ctx.strokeStyle = wood;
            ctx.beginPath();
            ctx.moveTo(a.x + ox + jitter(0.8), a.y + oy + jitter(0.8));
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox + jitter(0.8), b.y + oy + jitter(0.8));
            ctx.stroke();

            // grain line
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = woodDark;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(a.x + ox, a.y + oy);
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox, b.y + oy);
            ctx.stroke();
            ctx.restore();
          }

          // rungs + cracks + moss
          const rungCount = clamp(Math.floor(len / 48) + 2, 4, 9);
          for (let i = 1; i <= rungCount; i++) {
            const t = i / (rungCount + 1);
            const px = a.x + dx * t + jitter(2.2);
            const py = a.y + dy * t + jitter(2.2);

            ctx.save();
            ctx.lineCap = "round";
            ctx.shadowColor = "rgba(0,0,0,0.24)";
            ctx.shadowBlur = 8;
            ctx.lineWidth = clamp(3.8 + rnd() * 1.2, 3.8, 5.4);
            ctx.strokeStyle = wood;
            ctx.beginPath();
            ctx.moveTo(px - nrm.x * rail + jitter(0.9), py - nrm.y * rail + jitter(0.9));
            ctx.lineTo(px + nrm.x * rail + jitter(0.9), py + nrm.y * rail + jitter(0.9));
            ctx.stroke();

            // cracks
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "rgba(40, 24, 12, 0.45)";
            ctx.lineWidth = 1;
            const crackN = 1 + Math.floor(rnd() * 3);
            for (let c = 0; c < crackN; c++) {
              const cx = px + (rnd() - 0.5) * 10;
              const cy = py + (rnd() - 0.5) * 6;
              ctx.beginPath();
              ctx.moveTo(cx, cy);
              ctx.lineTo(cx + (rnd() - 0.5) * 10, cy + (rnd() - 0.5) * 10);
              ctx.stroke();
            }

            // moss flecks near cracks
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = moss;
            const mossN = Math.floor(rnd() * 4);
            for (let m = 0; m < mossN; m++) {
              const mx = px + (rnd() - 0.5) * 18;
              const my = py + (rnd() - 0.5) * 10;
              ctx.beginPath();
              ctx.arc(mx, my, 1 + rnd() * 2.2, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.restore();
          }
        }

        drawSnake(ctx, rect, from, to) {
          // Black mamba-ish: tapered ribbon, gentle shine, wedge head.
          const rnd = mulberry32(seedPair(from, to) ^ 0x33c9);
          const a = this.squareToPx(from, rect);
          const b = this.squareToPx(to, rect);
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const bend = Math.min(140, Math.max(60, Math.hypot(dx, dy) * 0.18));
          const angle = Math.atan2(dy, dx) + (kind === "ladder" ? 0.55 : -0.55);
          const c1 = { x: a.x + Math.cos(angle) * bend, y: a.y + Math.sin(angle) * bend };
          const c2 = { x: b.x - Math.cos(angle) * bend, y: b.y - Math.sin(angle) * bend };
          const len = Math.hypot(dx, dy) || 1;
          const dir = { x: dx / len, y: dy / len };
          const nrm = { x: -dir.y, y: dir.x };

          ctx.save();
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          const steps = clamp(Math.floor(len / 16), 18, 60);
          const baseW = clamp(10 + rnd() * 6, 10, 18);
          const wiggle = clamp(10 + rnd() * 12, 10, 20);
          const phase = rnd() * Math.PI * 2;
          const freq = 2.1 + rnd() * 1.6;

          if (kind === "ladder") {
            ctx.strokeStyle = "rgba(34, 197, 94, 0.72)";
            ctx.shadowColor = "rgba(34, 197, 94, 0.25)";
          } else {
            ctx.strokeStyle = "rgba(239, 68, 68, 0.72)";
            ctx.shadowColor = "rgba(239, 68, 68, 0.25)";
          const pts = [];
          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const ease = t * t * (3 - 2 * t);
            const px = a.x + dx * ease;
            const py = a.y + dy * ease;
            const w =
              Math.sin(phase + t * Math.PI * 2 * freq) *
              wiggle *
              (0.25 + 0.75 * Math.sin(Math.PI * t));
            const j = (rnd() - 0.5) * 0.9;
            pts.push({ x: px + nrm.x * w + j, y: py + nrm.y * w - j, t });
          }
          ctx.shadowBlur = 14;
          ctx.lineWidth = 6;

          const left = [];
          const right = [];
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const p0 = pts[Math.max(0, i - 1)];
            const p1 = pts[Math.min(pts.length - 1, i + 1)];
            const vx = p1.x - p0.x;
            const vy = p1.y - p0.y;
            const vlen = Math.hypot(vx, vy) || 1;
            const nx = -vy / vlen;
            const ny = vx / vlen;
            const taper = 0.18 + 0.82 * Math.sin(Math.PI * p.t);
            const width = baseW * taper * (0.92 + (rnd() - 0.5) * 0.08);
            left.push({ x: p.x + nx * width, y: p.y + ny * width, t: p.t });
            right.push({ x: p.x - nx * width, y: p.y - ny * width, t: p.t });
          }

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.38)";
          ctx.shadowBlur = 18;
          ctx.fillStyle = "rgba(10,10,10,0.92)";
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, b.x, b.y);
          ctx.stroke();
          ctx.moveTo(left[0].x, left[0].y);
          for (let i = 1; i < left.length; i++) ctx.lineTo(left[i].x, left[i].y);
          for (let i = right.length - 1; i >= 0; i--) ctx.lineTo(right[i].x, right[i].y);
          ctx.closePath();
          ctx.fill();

          // Inner highlight line
          // shine
          ctx.shadowBlur = 0;
          ctx.lineWidth = 2.5;
          ctx.strokeStyle = kind === "ladder" ? "rgba(255,255,255,0.55)" : "rgba(255,255,255,0.42)";
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = "rgba(255,255,255,0.22)";
          ctx.lineWidth = 2.2;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, b.x, b.y);
          const s0 = Math.floor(pts.length * 0.12);
          const s1 = Math.floor(pts.length * 0.85);
          for (let i = s0; i <= s1; i++) {
            const p = pts[i];
            const off = 2 + Math.sin(phase + p.t * 9) * 1.2;
            if (i === s0) ctx.moveTo(p.x + off, p.y - off);
            else ctx.lineTo(p.x + off, p.y - off);
          }
          ctx.stroke();

          // Endpoint dot
          ctx.fillStyle = "rgba(255, 255, 255, 0.78)";
          // head wedge at "from"
          const head = pts[0];
          const neck = pts[2] || pts[1] || head;
          const hvx = head.x - neck.x;
          const hvy = head.y - neck.y;
          const hvlen = Math.hypot(hvx, hvy) || 1;
          const fx = hvx / hvlen;
          const fy = hvy / hvlen;
          const px = -fy;
          const py = fx;
          const headL = clamp(16 + rnd() * 8, 16, 24);
          const headW = clamp(10 + rnd() * 6, 10, 16);

          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(12,12,12,0.96)";
          ctx.beginPath();
          ctx.arc(b.x, b.y, 3.5, 0, Math.PI * 2);
          ctx.moveTo(head.x + fx * headL, head.y + fy * headL);
          ctx.lineTo(head.x + px * headW, head.y + py * headW);
          ctx.lineTo(head.x - px * headW, head.y - py * headW);
          ctx.closePath();
          ctx.fill();

          // tiny eye glint
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.beginPath();
          ctx.arc(head.x + fx * (headL * 0.55) + px * 2.2, head.y + fy * (headL * 0.55) + py * 2.2, 1.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }

        for (const [from, to] of state.ladders.entries()) drawConnection(from, to, "ladder");
        for (const [from, to] of state.snakes.entries()) drawConnection(from, to, "snake");
      }

      function hasAnyEndpointCollision(mapping, start, end) {
        // Avoid overlapping endpoints with existing snakes/ladders.
        for (const [a, b] of mapping.entries()) {
          if (a === start || a === end || b === start || b === end) return true;
        }
        return false;
      }
      class Game {
        constructor(opts) {
          this.boardEl = opts.boardEl;
          this.canvasEl = opts.canvasEl;
          this.gridEl = opts.gridEl;
          this.piecesEl = opts.piecesEl;
          this.rollBtn = opts.rollBtn;
          this.newBtn = opts.newBtn;
          this.resetBtn = opts.resetBtn;
          this.logEl = opts.logEl;
          this.hud = opts.hud;

      function generateBoard() {
        // Clear
        state.snakes.clear();
        state.ladders.clear();
          this.renderer = new BoardRenderer(this.boardEl, this.canvasEl);

        // Targets: classic-ish density but randomized.
        const ladderTarget = 7;
        const snakeTarget = 7;
          this.board = { snakes: new Map(), ladders: new Map() };
          this.players = [];
          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;

        const used = new Set([1, 100]);
          this._onResize = () => this.redraw();
        }

        function canUse(x) {
          return x >= 2 && x <= 99 && !used.has(x);
        init(playerCount) {
          buildGrid(this.gridEl);
          this.newBoard();
          this.startPlayers(playerCount);
          this.bind();
          this.redraw();
          this.log("All set. Try your luck.");
          this.setButtons(true);
        }

        function addPair(kind) {
          let tries = 0;
          while (tries++ < 2500) {
            // Choose from/to ranges that feel fair.
            let from, to;
            if (kind === "ladder") {
              from = randInt(2, 75);
              to = randInt(from + 10, Math.min(99, from + 35));
            } else {
              from = randInt(15, 99);
              to = randInt(Math.max(2, from - 35), from - 10);
        bind() {
          this.rollBtn.addEventListener("click", () => this.takeTurn());
          this.newBtn.addEventListener("click", () => this.reset(true));
          this.resetBtn.addEventListener("click", () => this.reset(false));
          window.addEventListener("resize", this._onResize);

          window.addEventListener("keydown", (e) => {
            const activeView = document.querySelector(".view.active");
            if (!activeView || !activeView.contains(this.boardEl)) return;
            if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              this.takeTurn();
            } else if (e.key === "r" || e.key === "R") {
              e.preventDefault();
              this.reset(false);
            }
          });
        }

            if (from === to) continue;
            if (!canUse(from) || !canUse(to)) continue;
        destroy() {
          window.removeEventListener("resize", this._onResize);
        }

            // Prevent direct conflicts
            if (state.ladders.has(from) || state.snakes.has(from)) continue;
            if (state.ladders.has(to) || state.snakes.has(to)) continue;
        setButtons(enabled) {
          this.rollBtn.disabled = !enabled;
          this.newBtn.disabled = !enabled;
          this.resetBtn.disabled = !enabled;
        }

            // Avoid shared endpoints within same kind and across kinds
            if (
              hasAnyEndpointCollision(state.ladders, from, to) ||
              hasAnyEndpointCollision(state.snakes, from, to)
            )
              continue;
        log(text) {
          const p = document.createElement("p");
          p.textContent = text;
          this.logEl.prepend(p);
          // keep log small-ish
          while (this.logEl.childElementCount > 14) this.logEl.removeChild(this.logEl.lastElementChild);
        }

            // Avoid ladder start immediately being snake head etc.
            if (state.snakes.has(to) || state.ladders.has(to)) continue;
        clearLog() {
          this.logEl.innerHTML = "";
        }

            // Avoid pairs that jump across too much of the board (keeps it fun)
            const dist = Math.abs(to - from);
            if (dist < 10 || dist > 40) continue;

            // Accept
            if (kind === "ladder") state.ladders.set(from, to);
            else state.snakes.set(from, to);

            used.add(from);
            used.add(to);
            return true;
        hasEndpointCollision(map, start, end) {
          for (const [a, b] of map.entries()) {
            if (a === start || a === end || b === start || b === end) return true;
          }
          return false;
        }

        while (state.ladders.size < ladderTarget) {
          if (!addPair("ladder")) break;
        }
        while (state.snakes.size < snakeTarget) {
          if (!addPair("snake")) break;
        }
        newBoard() {
          this.board.snakes.clear();
          this.board.ladders.clear();
          const used = new Set([1, 100]);

        els.ladderCount.textContent = String(state.ladders.size);
        els.snakeCount.textContent = String(state.snakes.size);
          const ladderTarget = 7;
          const snakeTarget = 7;

        drawBoardNumbersAndBadges();
        drawPaths();
      }
          const canUse = (x) => x >= 2 && x <= 99 && !used.has(x);

      function sleep(ms) {
        return new Promise((r) => setTimeout(r, ms));
      }
          const addPair = (kind) => {
            for (let tries = 0; tries < 3000; tries++) {
              let from, to;
              if (kind === "ladder") {
                from = randInt(2, 75);
                to = randInt(from + 12, Math.min(99, from + 38));
              } else {
                from = randInt(18, 99);
                to = randInt(Math.max(2, from - 38), from - 12);
              }
              if (!canUse(from) || !canUse(to)) continue;
              if (this.board.ladders.has(from) || this.board.snakes.has(from)) continue;
              if (this.board.ladders.has(to) || this.board.snakes.has(to)) continue;
              if (this.hasEndpointCollision(this.board.ladders, from, to)) continue;
              if (this.hasEndpointCollision(this.board.snakes, from, to)) continue;
              const dist = Math.abs(to - from);
              if (dist < 12 || dist > 42) continue;
              if (kind === "ladder") this.board.ladders.set(from, to);
              else this.board.snakes.set(from, to);
              used.add(from);
              used.add(to);
              return true;
            }
            return false;
          };

      async function animateStepMove(from, to) {
        const dir = to >= from ? 1 : -1;
        const steps = Math.abs(to - from);
        for (let i = 1; i <= steps; i++) {
          setTokenPosition(from + dir * i, { animate: true });
          await sleep(110);
          while (this.board.ladders.size < ladderTarget) if (!addPair("ladder")) break;
          while (this.board.snakes.size < snakeTarget) if (!addPair("snake")) break;
        }
      }

      async function doTurn() {
        if (state.locked || state.finished) return;
        startPlayers(n) {
          this.players = [];
          this.piecesEl.innerHTML = "";

        state.locked = true;
        setButtonsEnabled(false);
          const shapes = shuffle([
            { id: "p-shoe", name: "shoe" },
            { id: "p-hat", name: "wizard hat" },
            { id: "p-dog", name: "dog" },
          ]).slice(0, n);

        const roll = rollDie();
        state.lastRoll = roll;
        state.turns += 1;
        updateStats();
          for (let i = 0; i < n; i++) {
            const s = shapes[i];
            const el = createPiece(s.id, s.name);
            this.piecesEl.appendChild(el);
            this.players.push({ pos: 1, name: s.name, el });
          }

        logLine(`Turn ${state.turns}: you rolled a ${roll}.`);
        toast(`Rolled ${roll}`);
          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;
          this.updateHud();
          this.placePieces(false);
        }

        const target = state.pos + roll;
        if (target > 100) {
          logLine(`Too high — you stay on ${state.pos}.`);
          state.locked = false;
          setButtonsEnabled(true);
          updateStats();
          return;
        reset(newBoard) {
          this.setButtons(false);
          this.clearLog();
          if (newBoard) this.newBoard();
          for (const p of this.players) p.pos = 1;
          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;
          this.redraw();
          this.placePieces(false);
          this.updateHud();
          this.log(newBoard ? "Fresh board. Same bad luck." : "Back to square one.");
          this.setButtons(true);
        }

        const start = state.pos;
        await animateStepMove(start, target);
        state.pos = target;
        updateStats();
        redraw() {
          this.renderer.draw(this.board);
          this.placePieces(false);
        }

        // Apply snakes/ladders after landing
        if (state.ladders.has(state.pos)) {
          const next = state.ladders.get(state.pos);
          logLine(`Ladder! Climb from ${state.pos} to ${next}.`);
          toast(`Ladder ↑ ${state.pos} → ${next}`);
          await sleep(220);
          await animateStepMove(state.pos, next);
          state.pos = next;
          updateStats();
        } else if (state.snakes.has(state.pos)) {
          const next = state.snakes.get(state.pos);
          logLine(`Snake! Slide from ${state.pos} to ${next}.`);
          toast(`Snake ↓ ${state.pos} → ${next}`);
          await sleep(220);
          await animateStepMove(state.pos, next);
          state.pos = next;
          updateStats();
        updateHud() {
          const p = this.players[this.current];
          if (!p) return;
          if (this.hud.player) this.hud.player.textContent = String(this.current + 1);
          if (this.hud.turn) this.hud.turn.textContent = String(this.turn);
          if (this.hud.pos) this.hud.pos.textContent = String(p.pos);
          if (this.hud.last) this.hud.last.textContent = this.last == null ? "—" : String(this.last);
          if (this.hud.piece) this.hud.piece.textContent = p.name;
        }

        if (state.pos === 100) {
          state.finished = true;
          logLine(`🎉 You reached 100 in ${state.turns} turns. You win!`);
          toast(`You win in ${state.turns} turns!`);
        placePieces(animate) {
          const rect = this.boardEl.getBoundingClientRect();
          const inset = 14;
          const inner = { left: inset, top: inset, w: rect.width - inset * 2, h: rect.height - inset * 2 };

          const buckets = new Map();
          for (let i = 0; i < this.players.length; i++) {
            const pos = this.players[i].pos;
            if (!buckets.has(pos)) buckets.set(pos, []);
            buckets.get(pos).push(i);
          }

          for (const [pos, idxs] of buckets.entries()) {
            const { x, y } = coordForSquare(pos);
            const cx = inner.left + inner.w * x;
            const cy = inner.top + inner.h * y;
            const base = offsetsForCount(idxs.length, 12);

            idxs.forEach((pi, j) => {
              const pl = this.players[pi];
              const off = base[j] || { x: 0, y: 0, s: 1 };
              const jx = (Math.random() - 0.5) * 1.2;
              const jy = (Math.random() - 0.5) * 1.2;
              const rot = (Math.random() - 0.5) * 2;
              pl.el.style.transition = animate ? "left 180ms ease, top 180ms ease, transform 180ms ease" : "none";
              pl.el.style.left = `${cx + off.x + jx}px`;
              pl.el.style.top = `${cy + off.y + jy}px`;
              pl.el.style.transform = `translate(-50%, -50%) scale(${off.s}) rotate(${rot}deg)`;
            });
          }
        }

        state.locked = false;
        setButtonsEnabled(true);
        updateStats();
      }
        sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

      function resetRun({ keepBoard = true } = {}) {
        state.pos = 1;
        state.lastRoll = null;
        state.turns = 0;
        state.locked = false;
        state.finished = false;
        async walk(pl, from, to) {
          const dir = to >= from ? 1 : -1;
          const steps = Math.abs(to - from);
          for (let i = 1; i <= steps; i++) {
            pl.pos = from + dir * i;
            this.placePieces(true);
            await this.sleep(85);
          }
        }

        clearLog();
        logLine("New run started. Roll to begin!");
        async takeTurn() {
          if (this.locked || this.finished) return;
          const pl = this.players[this.current];
          if (!pl) return;

        if (!keepBoard) generateBoard();
          this.locked = true;
          this.setButtons(false);

        updateStats();
        setTokenPosition(1, { animate: false });
      }
          const roll = randInt(1, 6);
          this.last = roll;
          const who = this.players.length > 1 ? `Player ${this.current + 1}` : "You";
          this.log(`${who} rolled a ${roll}.`);
          this.updateHud();

      function ensureLayoutAndRedraw() {
        // Token and canvas depend on boardWrap size.
        setTokenPosition(state.pos, { animate: false });
        drawPaths();
      }
          const target = pl.pos + roll;
          if (target > 100) {
            this.log("Too much. Stay put.");
            this.locked = false;
            this.setButtons(true);
            this.advance();
            return;
          }

      function init() {
        generateBoard();
        resetRun({ keepBoard: true });
          const start = pl.pos;
          await this.walk(pl, start, target);

        els.rollBtn.addEventListener("click", doTurn);
        els.resetBtn.addEventListener("click", () => resetRun({ keepBoard: true }));
        els.newBoardBtn.addEventListener("click", () => resetRun({ keepBoard: false }));
          if (this.board.ladders.has(pl.pos)) {
            const next = this.board.ladders.get(pl.pos);
            this.log("Nice. Up you go.");
            await this.sleep(180);
            await this.walk(pl, pl.pos, next);
          } else if (this.board.snakes.has(pl.pos)) {
            const next = this.board.snakes.get(pl.pos);
            this.log("Oh. That one had opinions.");
            await this.sleep(180);
            await this.walk(pl, pl.pos, next);
          }

        window.addEventListener("resize", () => {
          // Debounce-ish via rAF
          window.requestAnimationFrame(ensureLayoutAndRedraw);
        });
          this.updateHud();
          this.placePieces(true);

        window.addEventListener("keydown", (e) => {
          if (e.key === " " || e.key === "Spacebar") {
            e.preventDefault();
            doTurn();
          if (pl.pos === 100) {
            this.finished = true;
            this.winner = this.current;
            this.log(this.players.length > 1 ? `Player ${this.current + 1} made it.` : "Made it. Finally.");
            this.locked = false;
            this.setButtons(false);
            return;
          }
          if (e.key === "r" || e.key === "R") {
            e.preventDefault();
            resetRun({ keepBoard: true });

          this.locked = false;
          this.setButtons(true);
          this.advance();
        }

        advance() {
          if (this.players.length <= 1) {
            this.turn += 1;
            this.updateHud();
            return;
          }
          this.current = (this.current + 1) % this.players.length;
          this.turn += 1;
          this.updateHud();
        }
      }

      function showView(which) {
        $("view-single").classList.toggle("active", which === "single");
        $("view-multi").classList.toggle("active", which === "multi");
      }

      // Single-player game
      const singleGame = new Game({
        boardEl: $("single-board"),
        canvasEl: $("single-canvas"),
        gridEl: $("single-grid"),
        piecesEl: $("single-pieces"),
        rollBtn: $("single-roll"),
        newBtn: $("single-new"),
        resetBtn: $("single-reset"),
        logEl: $("single-log"),
        hud: {
          turn: $("single-turn"),
          pos: $("single-pos"),
          last: $("single-last"),
          piece: $("single-piece"),
          player: null,
        },
      });

      let multiGame = null;

      function startMulti(n) {
        $("multi-setup").style.display = "none";
        $("multi-stage").style.display = "grid";
        if (multiGame) multiGame.destroy();
        multiGame = new Game({
          boardEl: $("multi-board"),
          canvasEl: $("multi-canvas"),
          gridEl: $("multi-grid"),
          piecesEl: $("multi-pieces"),
          rollBtn: $("multi-roll"),
          newBtn: $("multi-new"),
          resetBtn: $("multi-reset"),
          logEl: $("multi-log"),
          hud: {
            player: $("multi-player"),
            pos: $("multi-pos"),
            last: $("multi-last"),
            turn: null,
            piece: null,
          },
        });
        multiGame.init(n);
        multiGame.log("Alright. Be nice.");
      }

        setButtonsEnabled(true);
      $("multi-2").addEventListener("click", () => startMulti(2));
      $("multi-3").addEventListener("click", () => startMulti(3));

      function route() {
        const h = (location.hash || "").toLowerCase();
        if (h === "#multiplayer") {
          showView("multi");
          // show setup unless a multiplayer game was started
          if (!$("multi-stage").style.display || $("multi-stage").style.display === "none") {
            $("multi-setup").style.display = "block";
            $("multi-stage").style.display = "none";
          }
        } else {
          showView("single");
        }
      }

      init();
      window.addEventListener("hashchange", route);

      // boot
      if (!location.hash) location.hash = "#single";
      singleGame.init(1);
      route();
    </script>
  </body>
</html>
