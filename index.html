<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LeNard’s board game</title>
    <meta name="description" content="LeNard’s board game — snakes, ladders, and a little bad luck." />
    <style>
      :root {
        --outside: #0c0f12;
        --outside2: #0a0b0d;
        --ink: rgba(240, 236, 229, 0.9);
        --ink2: rgba(240, 236, 229, 0.66);
        --ink3: rgba(240, 236, 229, 0.46);
        --deep-red: #5b0f14;
        --deep-red2: #4a0d11;
        --grid: rgba(20, 10, 10, 0.35);
        --grid2: rgba(255, 255, 255, 0.12);
        --paperSpeck: rgba(0, 0, 0, 0.08);
        --shadow: rgba(0, 0, 0, 0.55);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background:
          radial-gradient(1200px 600px at 25% 10%, rgba(100, 120, 140, 0.08), transparent 55%),
          radial-gradient(900px 520px at 85% 15%, rgba(80, 90, 70, 0.06), transparent 55%),
          linear-gradient(180deg, var(--outside), var(--outside2));
        color: var(--ink);
        font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.035), transparent 55%),
          radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.03), transparent 60%),
          repeating-linear-gradient(
            112deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 8px
          );
        opacity: 0.5;
      }

      a {
        color: inherit;
        text-decoration: none;
      }

      .view {
        min-height: 100%;
        display: none;
      }

      .view.active {
        display: block;
      }

      .shell {
        width: min(1400px, calc(100vw - 24px));
        margin: 0 auto;
        padding: 14px 0 18px;
      }

      .title {
        text-align: center;
        font-size: 20px;
        font-weight: 500;
        letter-spacing: 0.2px;
        margin: 6px 0 14px;
        color: rgba(240, 236, 229, 0.86);
      }

      .stage {
        display: flex;
        gap: 14px;
        align-items: flex-start;
      }

      /* Board dominates (>=80% width). */
      .boardArea {
        flex: 1 1 auto;
        min-width: 0;
      }

      .quietSide {
        width: clamp(160px, 18vw, 240px);
        flex: 0 0 auto;
        color: rgba(240, 236, 229, 0.82);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        line-height: 1.2;
        padding-top: 8px;
      }

      /* On small screens, stack controls under board but keep them visually quieter. */
      @media (max-width: 880px) {
        .stage {
          flex-direction: column;
        }
        .quietSide {
          width: 100%;
          max-width: 520px;
        }
      }

      .board {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        background: var(--deep-red);
        border-radius: 16px;
        overflow: hidden;
        box-shadow:
          0 22px 55px var(--shadow),
          inset 0 0 0 2px rgba(0, 0, 0, 0.22),
          inset 0 0 0 6px rgba(255, 255, 255, 0.05);
        transform: rotate(-0.35deg);
      }

      /* Cardboard / print imperfections */
      .board::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(circle at 18% 22%, rgba(255, 255, 255, 0.06), transparent 55%),
          radial-gradient(circle at 78% 68%, rgba(0, 0, 0, 0.16), transparent 60%),
          repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 7px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(0, 0, 0, 0.03),
            rgba(0, 0, 0, 0.03) 1px,
            transparent 1px,
            transparent 9px
          );
        mix-blend-mode: overlay;
        opacity: 0.9;
      }

      .board::after {
        content: "";
        position: absolute;
        inset: -1px;
        pointer-events: none;
        background:
          radial-gradient(circle at 50% 50%, transparent 58%, rgba(0, 0, 0, 0.22) 95%);
        opacity: 0.9;
      }

      .boardGrid {
        position: absolute;
        inset: 14px;
        border-radius: 12px;
        overflow: hidden;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.24);
      }

      .cell {
        position: relative;
        border-right: 1px solid rgba(0, 0, 0, 0.22);
        border-bottom: 1px solid rgba(0, 0, 0, 0.22);
        background:
          radial-gradient(circle at 25% 20%, rgba(255, 255, 255, 0.06), transparent 60%),
          radial-gradient(circle at 70% 75%, rgba(0, 0, 0, 0.1), transparent 62%);
      }

      .cell:nth-child(10n) {
        border-right: none;
      }
      .cell:nth-last-child(-n + 10) {
        border-bottom: none;
      }

      .cell::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        background:
          radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.04), transparent 55%),
          radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.06), transparent 55%);
        opacity: 0.65;
      }

      /* Very small numbers, barely there */
      .cellNum {
        position: absolute;
        top: 6px;
        left: 7px;
        font-size: 9px;
        letter-spacing: 0.2px;
        color: rgba(255, 255, 255, 0.36);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
        user-select: none;
      }

      canvas.paths {
        position: absolute;
        inset: 14px;
        width: calc(100% - 28px);
        height: calc(100% - 28px);
        pointer-events: none;
      }

      .pieces {
        position: absolute;
        inset: 14px;
        pointer-events: none;
      }

      .piece {
        position: absolute;
        width: 30px;
        height: 30px;
        transform: translate(-50%, -50%);
        filter:
          drop-shadow(0 10px 16px rgba(0, 0, 0, 0.35))
          drop-shadow(0 2px 0 rgba(255, 255, 255, 0.08));
        opacity: 0.98;
      }

      .piece svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .pieceLabel {
        position: absolute;
        left: 50%;
        top: 34px;
        transform: translateX(-50%);
        font-size: 10px;
        color: rgba(240, 236, 229, 0.6);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        white-space: nowrap;
        display: none;
      }

      .quietSide .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(240, 236, 229, 0.14);
      }

      .quietSide .row:last-child {
        border-bottom: none;
      }

      .quietSide .label {
        color: rgba(240, 236, 229, 0.6);
      }

      .quietSide .value {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        color: rgba(240, 236, 229, 0.82);
      }

      .controls {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }

      button {
        appearance: none;
        background: rgba(240, 236, 229, 0.06);
        border: 1px solid rgba(240, 236, 229, 0.16);
        color: rgba(240, 236, 229, 0.86);
        padding: 10px 10px;
        border-radius: 12px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        letter-spacing: 0.2px;
        cursor: pointer;
        transition: background 120ms ease, transform 120ms ease;
      }

      button:hover {
        background: rgba(240, 236, 229, 0.1);
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0px);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
      }

      .minorLink {
        display: inline-block;
        margin-top: 10px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        color: rgba(240, 236, 229, 0.62);
        text-decoration: underline;
        text-decoration-style: dotted;
        text-underline-offset: 4px;
      }

      .log {
        margin-top: 12px;
        padding: 8px 0 0;
        color: rgba(240, 236, 229, 0.7);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        max-height: 72px; /* ~1/4 of the old log height */
        overflow: auto;
      }

      .log p {
        margin: 0 0 6px 0;
      }

      .setup {
        margin: 12px auto 0;
        width: min(520px, calc(100vw - 24px));
        padding: 16px 14px;
        border: 1px solid rgba(240, 236, 229, 0.14);
        border-radius: 16px;
        background: rgba(240, 236, 229, 0.04);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        color: rgba(240, 236, 229, 0.86);
      }

      .setup h2 {
        margin: 0 0 10px 0;
        font-size: 14px;
        font-weight: 650;
      }

      .setup .choices {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .choiceBtn {
        padding: 10px 12px;
      }

      .note {
        margin-top: 10px;
        color: rgba(240, 236, 229, 0.62);
        font-size: 12px;
        line-height: 1.25;
      }

      .srOnly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <!-- Hidden SVG defs for metallic pieces -->
    <svg class="srOnly" aria-hidden="true">
      <defs>
        <linearGradient id="silverGrad" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#fafafa" stop-opacity="0.98" />
          <stop offset="0.22" stop-color="#d9d9d9" stop-opacity="0.98" />
          <stop offset="0.5" stop-color="#bdbdbd" stop-opacity="0.98" />
          <stop offset="0.78" stop-color="#f3f3f3" stop-opacity="0.98" />
          <stop offset="1" stop-color="#9f9f9f" stop-opacity="0.98" />
        </linearGradient>
        <linearGradient id="silverEdge" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0" stop-color="rgba(0,0,0,0.22)" />
          <stop offset="1" stop-color="rgba(255,255,255,0.22)" />
        </linearGradient>
        <filter id="metalRough" x="-20%" y="-20%" width="140%" height="140%">
          <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="7" />
          <feColorMatrix type="matrix" values="
            1 0 0 0 0
            0 1 0 0 0
            0 0 1 0 0
            0 0 0 0.16 0" />
          <feComposite operator="in" in2="SourceGraphic" />
          <feBlend mode="overlay" in2="SourceGraphic" />
        </filter>

        <symbol id="piece-shoe" viewBox="0 0 64 64">
          <path
            d="M10 40c6 0 10-6 14-14 3-7 7-10 12-10 4 0 6 3 8 6 2 4 4 7 9 9 4 2 7 4 7 8 0 6-6 9-16 9H18c-8 0-12-3-12-8 0-3 2-6 4-6z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M16 41c9 2 20 2 32 0"
            stroke="rgba(0,0,0,0.22)"
            stroke-width="1.2"
            stroke-linecap="round"
            opacity="0.55"
          />
        </symbol>

        <symbol id="piece-hat" viewBox="0 0 64 64">
          <path
            d="M30 10c10 10 16 22 16 30 0 7-6 10-14 10-7 0-14-3-14-10 0-9 4-18 12-30z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M10 44c8 5 36 5 44 0"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
        </symbol>

        <symbol id="piece-dog" viewBox="0 0 64 64">
          <path
            d="M18 44c0-10 7-18 16-18 7 0 12 4 14 9 3 0 6 2 6 6 0 5-4 8-9 8-1 5-6 9-13 9-9 0-14-6-14-14z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M23 33c-3-2-6-5-6-9 0-5 5-7 9-5"
            fill="none"
            stroke="rgba(0,0,0,0.24)"
            stroke-width="1.3"
            stroke-linecap="round"
            opacity="0.6"
          />
        </symbol>
      </defs>
    </svg>

    <!-- SINGLE PLAYER VIEW -->
    <section class="view active" id="singleView" aria-label="Single player">
      <div class="shell">
        <div class="title">LeNard’s board game</div>
        <div class="stage">
          <div class="boardArea">
            <div class="board" id="singleBoard">
              <canvas class="paths" id="singleCanvas" width="1000" height="1000" aria-hidden="true"></canvas>
              <div class="boardGrid" id="singleGrid" aria-hidden="true"></div>
              <div class="pieces" id="singlePieces" aria-hidden="true"></div>
            </div>
          </div>
          <aside class="quietSide" aria-label="Controls">
            <div class="row">
              <div class="label">Turn</div>
              <div class="value" id="singleTurn">1</div>
            </div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="singlePos">1</div>
            </div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="singleLast">—</div>
            </div>
            <div class="row">
              <div class="label">Piece</div>
              <div class="value" id="singlePieceName">—</div>
            </div>
            <div class="controls">
              <button id="singleRoll" type="button">Roll</button>
              <button id="singleNewBoard" type="button">New board</button>
              <button id="singleReset" type="button">Reset</button>
            </div>
            <a class="minorLink" href="#multiplayer" id="toMulti">Multiplayer</a>
            <div class="log" id="singleLog" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

    <!-- MULTIPLAYER VIEW -->
    <section class="view" id="multiView" aria-label="Multiplayer">
      <div class="shell">
        <div class="title">LeNard’s board game</div>

        <div class="setup" id="multiSetup">
          <h2>Multiplayer</h2>
          <div class="choices" role="group" aria-label="Choose number of players">
            <button class="choiceBtn" id="choose2" type="button">2 players</button>
            <button class="choiceBtn" id="choose3" type="button">3 players</button>
          </div>
          <div class="note">
            Each player gets a little silver thing. Try not to get swallowed immediately.
            <div style="margin-top: 8px">
              <a class="minorLink" href="#single" id="toSingle">Back to single-player</a>
            </div>
          </div>
        </div>

        <div class="stage" id="multiStage" style="display: none">
          <div class="boardArea">
            <div class="board" id="multiBoard">
              <canvas class="paths" id="multiCanvas" width="1000" height="1000" aria-hidden="true"></canvas>
              <div class="boardGrid" id="multiGrid" aria-hidden="true"></div>
              <div class="pieces" id="multiPieces" aria-hidden="true"></div>
            </div>
          </div>
          <aside class="quietSide" aria-label="Controls">
            <div class="row">
              <div class="label">Player</div>
              <div class="value" id="multiPlayer">1</div>
            </div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="multiPos">1</div>
            </div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="multiLast">—</div>
            </div>
            <div class="controls">
              <button id="multiRoll" type="button">Roll</button>
              <button id="multiNewBoard" type="button">New board</button>
              <button id="multiReset" type="button">Reset</button>
            </div>
            <a class="minorLink" href="#single">Single-player</a>
            <div class="log" id="multiLog" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

    <script>
      const $ = (id) => document.getElementById(id);

      function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
      }

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function rollDie() {
        return randInt(1, 6);
      }

      function mulberry32(seed) {
        let a = seed >>> 0;
        return function () {
          a |= 0;
          a = (a + 0x6d2b79f5) | 0;
          let t = Math.imul(a ^ (a >>> 15), 1 | a);
          t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
          return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }

      function hashPair(a, b) {
        // Simple deterministic seed for (a,b)
        return ((a * 73856093) ^ (b * 19349663)) >>> 0;
      }

      function coordForSquare(n) {
        // Serpentine numbering: bottom row 1..10 L->R, next row 11..20 R->L, ...
        const idx = n - 1;
        const row = Math.floor(idx / 10); // 0..9 bottom->top
        const colInRow = idx % 10;
        const reversed = row % 2 === 1;
        const col = reversed ? 9 - colInRow : colInRow;
        const x = (col + 0.5) / 10;
        const y = 1 - (row + 0.5) / 10;
        return { x, y };
      }

      function pickUnique(items, count) {
        const arr = items.slice();
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr.slice(0, count);
      }

      function createPieceEl(shape, label) {
        const el = document.createElement("div");
        el.className = "piece";
        el.dataset.shape = shape;
        el.setAttribute("aria-hidden", "true");
        el.innerHTML = `
          <svg viewBox="0 0 64 64" role="img" aria-label="${label}">
            <use href="#piece-${shape}"></use>
          </svg>
          <div class="pieceLabel">${label}</div>
        `;
        return el;
      }

      function layoutOffsets(count, radius) {
        // Non-overlapping-ish offsets around a point.
        // Intentionally slightly imperfect (tiny jitter).
        if (count <= 1) return [{ x: 0, y: 0, s: 1 }];
        const base =
          count === 2
            ? [
                { x: -radius * 0.7, y: 0, s: 0.88 },
                { x: radius * 0.7, y: 0.1 * radius, s: 0.88 },
              ]
            : [
                { x: -radius * 0.65, y: radius * 0.35, s: 0.82 },
                { x: radius * 0.7, y: radius * 0.25, s: 0.82 },
                { x: 0.05 * radius, y: -radius * 0.65, s: 0.82 },
              ];
        return base.map((p) => ({
          x: p.x + (Math.random() - 0.5) * 1.2,
          y: p.y + (Math.random() - 0.5) * 1.2,
          s: p.s,
        }));
      }

      class BoardArt {
        constructor(boardEl, canvasEl) {
          this.boardEl = boardEl;
          this.canvasEl = canvasEl;
        }

        squareToPixel(n) {
          const rect = this.boardEl.getBoundingClientRect();
          const inset = 14;
          const inner = {
            left: inset,
            top: inset,
            w: rect.width - inset * 2,
            h: rect.height - inset * 2,
          };
          const { x, y } = coordForSquare(n);
          return { x: inner.left + inner.w * x, y: inner.top + inner.h * y };
        }

        resizeCanvas() {
          const rect = this.boardEl.getBoundingClientRect();
          const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
          this.canvasEl.width = Math.floor(rect.width * dpr);
          this.canvasEl.height = Math.floor(rect.height * dpr);
          const ctx = this.canvasEl.getContext("2d");
          if (!ctx) return null;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          return ctx;
        }

        draw(boardMap) {
          const ctx = this.resizeCanvas();
          if (!ctx) return;
          const rect = this.boardEl.getBoundingClientRect();
          ctx.clearRect(0, 0, rect.width, rect.height);

          // Slight ink smudge layer
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          for (let i = 0; i < 16; i++) {
            const x = Math.random() * rect.width;
            const y = Math.random() * rect.height;
            const r = 18 + Math.random() * 26;
            ctx.beginPath();
            ctx.ellipse(x, y, r * 1.2, r, (Math.random() - 0.5) * 0.6, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // Ladders first (so snakes can overlay a little)
          for (const [from, to] of boardMap.ladders.entries()) {
            this.drawLadder(ctx, from, to, hashPair(from, to) ^ 0x8f2a);
          }
          for (const [from, to] of boardMap.snakes.entries()) {
            this.drawSnake(ctx, from, to, hashPair(from, to) ^ 0x33c9);
          }
        }

        drawLadder(ctx, from, to, seed) {
          const rnd = mulberry32(seed);
          const a = this.squareToPixel(from);
          const b = this.squareToPixel(to);

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy);
          const ux = dx / (len || 1);
          const uy = dy / (len || 1);
          const nx = -uy;
          const ny = ux;

          // Rails spacing
          const rail = clamp(10 + rnd() * 5, 10, 16);
          const railW = clamp(4.6 + rnd() * 1.6, 4.6, 7.2);

          const woodBase = "rgba(136, 92, 58, 0.92)";
          const woodDark = "rgba(70, 42, 22, 0.55)";
          const woodHi = "rgba(250, 240, 220, 0.18)";

          function jitter(t) {
            return (rnd() - 0.5) * t;
          }

          // Rails
          for (const side of [-1, 1]) {
            const ox = nx * rail * side;
            const oy = ny * rail * side;
            ctx.save();
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.shadowColor = "rgba(0,0,0,0.25)";
            ctx.shadowBlur = 10;
            ctx.lineWidth = railW;
            ctx.strokeStyle = woodBase;
            ctx.beginPath();
            ctx.moveTo(a.x + ox + jitter(0.8), a.y + oy + jitter(0.8));

            // A slightly bowed rail (old wood)
            const mid = {
              x: (a.x + b.x) / 2 + nx * (rnd() - 0.5) * 18,
              y: (a.y + b.y) / 2 + ny * (rnd() - 0.5) * 18,
            };
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox + jitter(0.8), b.y + oy + jitter(0.8));
            ctx.stroke();

            // Dark grain line
            ctx.shadowBlur = 0;
            ctx.lineWidth = 1.3;
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = woodDark;
            ctx.beginPath();
            ctx.moveTo(a.x + ox, a.y + oy);
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox, b.y + oy);
            ctx.stroke();

            // Highlight edge
            ctx.globalAlpha = 0.7;
            ctx.strokeStyle = woodHi;
            ctx.lineWidth = 1.1;
            ctx.beginPath();
            ctx.moveTo(a.x + ox + nx * 1.2, a.y + oy + ny * 1.2);
            ctx.quadraticCurveTo(
              mid.x + ox + nx * 1.2,
              mid.y + oy + ny * 1.2,
              b.x + ox + nx * 1.2,
              b.y + oy + ny * 1.2,
            );
            ctx.stroke();
            ctx.restore();
          }

          // Rungs
          const rungCount = clamp(Math.floor(len / 48) + 2, 4, 9);
          for (let i = 1; i <= rungCount; i++) {
            const t = i / (rungCount + 1);
            const px = a.x + dx * t + (rnd() - 0.5) * 2.2;
            const py = a.y + dy * t + (rnd() - 0.5) * 2.2;

            ctx.save();
            ctx.lineCap = "round";
            ctx.shadowColor = "rgba(0,0,0,0.24)";
            ctx.shadowBlur = 8;
            ctx.lineWidth = clamp(3.8 + rnd() * 1.2, 3.8, 5.4);
            ctx.strokeStyle = woodBase;
            ctx.beginPath();
            ctx.moveTo(px - nx * rail + jitter(0.9), py - ny * rail + jitter(0.9));
            ctx.lineTo(px + nx * rail + jitter(0.9), py + ny * rail + jitter(0.9));
            ctx.stroke();

            // Little cracks (old, slightly broken)
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "rgba(40, 24, 12, 0.45)";
            ctx.lineWidth = 1;
            const crackN = 1 + Math.floor(rnd() * 3);
            for (let c = 0; c < crackN; c++) {
              const cx = px + (rnd() - 0.5) * 10;
              const cy = py + (rnd() - 0.5) * 6;
              ctx.beginPath();
              ctx.moveTo(cx, cy);
              ctx.lineTo(cx + (rnd() - 0.5) * 10, cy + (rnd() - 0.5) * 10);
              ctx.stroke();
            }

            // Moss flecks near cracks
            ctx.globalAlpha = 0.8;
            ctx.fillStyle = "rgba(34, 110, 52, 0.55)";
            const moss = Math.floor(rnd() * 4);
            for (let m = 0; m < moss; m++) {
              const mx = px + (rnd() - 0.5) * 18;
              const my = py + (rnd() - 0.5) * 10;
              ctx.beginPath();
              ctx.arc(mx, my, 1 + rnd() * 2.2, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }
        }

        drawSnake(ctx, from, to, seed) {
          // "Black mamba-ish": tapered, glossy black body, slight lateral undulation, a head.
          const rnd = mulberry32(seed);
          const a = this.squareToPixel(from);
          const b = this.squareToPixel(to);
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy);
          const steps = clamp(Math.floor(len / 16), 18, 60);
          const baseW = clamp(10 + rnd() * 6, 10, 18);
          const wiggle = clamp(10 + rnd() * 12, 10, 20);

          // A curvy centerline sampled as points
          const pts = [];
          const dir = { x: dx / (len || 1), y: dy / (len || 1) };
          const nrm = { x: -dir.y, y: dir.x };

          const phase = rnd() * Math.PI * 2;
          const freq = 2.1 + rnd() * 1.6;
          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const ease = t * t * (3 - 2 * t);
            const px = a.x + dx * ease;
            const py = a.y + dy * ease;
            const w = Math.sin(phase + t * Math.PI * 2 * freq) * wiggle * (0.25 + 0.75 * Math.sin(Math.PI * t));
            const jitter = (rnd() - 0.5) * 0.9;
            pts.push({
              x: px + nrm.x * w + jitter,
              y: py + nrm.y * w - jitter,
              t,
            });
          }

          // Build a filled ribbon (left/right offsets)
          const left = [];
          const right = [];
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const p0 = pts[Math.max(0, i - 1)];
            const p1 = pts[Math.min(pts.length - 1, i + 1)];
            const vx = p1.x - p0.x;
            const vy = p1.y - p0.y;
            const vlen = Math.hypot(vx, vy) || 1;
            const nx = -vy / vlen;
            const ny = vx / vlen;
            const taper = 0.18 + 0.82 * Math.sin(Math.PI * p.t);
            const width = baseW * taper * (0.92 + (rnd() - 0.5) * 0.08);
            left.push({ x: p.x + nx * width, y: p.y + ny * width, t: p.t });
            right.push({ x: p.x - nx * width, y: p.y - ny * width, t: p.t });
          }

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.38)";
          ctx.shadowBlur = 18;

          // Body fill
          ctx.fillStyle = "rgba(10, 10, 10, 0.92)";
          ctx.beginPath();
          ctx.moveTo(left[0].x, left[0].y);
          for (let i = 1; i < left.length; i++) ctx.lineTo(left[i].x, left[i].y);
          for (let i = right.length - 1; i >= 0; i--) ctx.lineTo(right[i].x, right[i].y);
          ctx.closePath();
          ctx.fill();

          // Gloss highlight (thin, not perfect)
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = "rgba(255,255,255,0.22)";
          ctx.lineWidth = 2.2;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          const hlStart = Math.floor(pts.length * 0.12);
          const hlEnd = Math.floor(pts.length * 0.85);
          for (let i = hlStart; i <= hlEnd; i++) {
            const p = pts[i];
            const offset = 2 + Math.sin(phase + p.t * 9) * 1.2;
            if (i === hlStart) ctx.moveTo(p.x + offset, p.y - offset);
            else ctx.lineTo(p.x + offset, p.y - offset);
          }
          ctx.stroke();

          // Head (at "from") - mamba-ish wedge
          const head = pts[0];
          const neck = pts[2] || pts[1] || head;
          const hx = head.x;
          const hy = head.y;
          const vx = head.x - neck.x;
          const vy = head.y - neck.y;
          const vlen = Math.hypot(vx, vy) || 1;
          const fx = vx / vlen;
          const fy = vy / vlen;
          const px = -fy;
          const py = fx;
          const headL = clamp(16 + rnd() * 8, 16, 24);
          const headW = clamp(10 + rnd() * 6, 10, 16);

          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(12, 12, 12, 0.96)";
          ctx.beginPath();
          ctx.moveTo(hx + fx * headL, hy + fy * headL);
          ctx.lineTo(hx + px * headW, hy + py * headW);
          ctx.lineTo(hx - px * headW, hy - py * headW);
          ctx.closePath();
          ctx.fill();

          // Small eye glint
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.beginPath();
          ctx.arc(hx + fx * (headL * 0.55) + px * 2.2, hy + fy * (headL * 0.55) + py * 2.2, 1.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      class Game {
        constructor(opts) {
          this.boardEl = opts.boardEl;
          this.gridEl = opts.gridEl;
          this.canvasEl = opts.canvasEl;
          this.piecesEl = opts.piecesEl;
          this.rollBtn = opts.rollBtn;
          this.newBoardBtn = opts.newBoardBtn;
          this.resetBtn = opts.resetBtn;
          this.logEl = opts.logEl;
          this.turnEl = opts.turnEl;
          this.posEl = opts.posEl;
          this.lastEl = opts.lastEl;
          this.playerEl = opts.playerEl || null;
          this.pieceNameEl = opts.pieceNameEl || null;

          this.art = new BoardArt(this.boardEl, this.canvasEl);

          this.board = { snakes: new Map(), ladders: new Map() };
          this.players = [];
          this.current = 0;
          this.turnCount = 1;
          this.lastRoll = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;

          this._onResize = () => this.redraw();
        }

        init(numPlayers) {
          this.buildGrid();
          this.generateBoard();
          this.startPlayers(numPlayers);
          this.bind();
          this.redraw();
          this.log("All set. Try your luck.");
        }

        destroy() {
          window.removeEventListener("resize", this._onResize);
        }

        bind() {
          this.rollBtn.addEventListener("click", () => this.turn());
          this.newBoardBtn.addEventListener("click", () => this.reset({ newBoard: true }));
          this.resetBtn.addEventListener("click", () => this.reset({ newBoard: false }));
          window.addEventListener("resize", this._onResize);

          window.addEventListener("keydown", (e) => {
            if (document.querySelector(".view.active")?.contains(this.boardEl) !== true) return;
            if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              this.turn();
              return;
            }
            if (e.key === "r" || e.key === "R") {
              e.preventDefault();
              this.reset({ newBoard: false });
            }
          });
        }

        setButtons(enabled) {
          this.rollBtn.disabled = !enabled;
          this.newBoardBtn.disabled = !enabled;
          this.resetBtn.disabled = !enabled;
        }

        log(text) {
          const p = document.createElement("p");
          p.textContent = text;
          this.logEl.prepend(p);
        }

        clearLog() {
          this.logEl.innerHTML = "";
        }

        buildGrid() {
          this.gridEl.innerHTML = "";
          // Visual top-left to bottom-right, but serpentine numbers
          for (let visualRow = 9; visualRow >= 0; visualRow--) {
            for (let visualCol = 0; visualCol < 10; visualCol++) {
              const cell = document.createElement("div");
              cell.className = "cell";

              const logicalRow = 9 - visualRow;
              const reversed = logicalRow % 2 === 1;
              const colInRow = reversed ? 9 - visualCol : visualCol;
              const n = logicalRow * 10 + colInRow + 1;

              const num = document.createElement("div");
              num.className = "cellNum";
              num.textContent = String(n);
              cell.appendChild(num);

              this.gridEl.appendChild(cell);
            }
          }
        }

        hasEndpointCollision(map, start, end) {
          for (const [a, b] of map.entries()) {
            if (a === start || a === end || b === start || b === end) return true;
          }
          return false;
        }

        generateBoard() {
          this.board.snakes.clear();
          this.board.ladders.clear();
          const used = new Set([1, 100]);

          const snakeTarget = 7;
          const ladderTarget = 7;

          const canUse = (x) => x >= 2 && x <= 99 && !used.has(x);

          const addPair = (kind) => {
            let tries = 0;
            while (tries++ < 3000) {
              let from, to;
              if (kind === "ladder") {
                from = randInt(2, 75);
                to = randInt(from + 12, Math.min(99, from + 38));
              } else {
                from = randInt(18, 99);
                to = randInt(Math.max(2, from - 38), from - 12);
              }
              if (!canUse(from) || !canUse(to)) continue;
              if (this.board.ladders.has(from) || this.board.snakes.has(from)) continue;
              if (this.board.ladders.has(to) || this.board.snakes.has(to)) continue;
              if (this.hasEndpointCollision(this.board.ladders, from, to)) continue;
              if (this.hasEndpointCollision(this.board.snakes, from, to)) continue;
              const dist = Math.abs(to - from);
              if (dist < 12 || dist > 42) continue;
              if (kind === "ladder") this.board.ladders.set(from, to);
              else this.board.snakes.set(from, to);
              used.add(from);
              used.add(to);
              return true;
            }
            return false;
          };

          while (this.board.ladders.size < ladderTarget) {
            if (!addPair("ladder")) break;
          }
          while (this.board.snakes.size < snakeTarget) {
            if (!addPair("snake")) break;
          }
        }

        startPlayers(n) {
          this.players = [];
          this.piecesEl.innerHTML = "";

          const shapes = pickUnique(["shoe", "hat", "dog"], n);
          const names = {
            shoe: "shoe",
            hat: "wizard hat",
            dog: "dog",
          };

          for (let i = 0; i < n; i++) {
            const shape = shapes[i];
            const el = createPieceEl(shape, names[shape]);
            el.dataset.player = String(i + 1);
            this.piecesEl.appendChild(el);
            this.players.push({
              pos: 1,
              shape,
              name: names[shape],
              el,
            });
          }

          this.current = 0;
          this.turnCount = 1;
          this.lastRoll = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;

          if (this.pieceNameEl && this.players[0]) {
            this.pieceNameEl.textContent = this.players[0].name;
          }
          this.updateHud();
          this.placePieces({ animate: false });
        }

        reset({ newBoard }) {
          this.setButtons(false);
          this.clearLog();
          if (newBoard) this.generateBoard();
          for (const p of this.players) p.pos = 1;
          this.current = 0;
          this.turnCount = 1;
          this.lastRoll = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;
          this.redraw();
          this.placePieces({ animate: false });
          this.updateHud();
          this.log(newBoard ? "Fresh board. Same bad luck." : "Back to square one.");
          this.setButtons(true);
        }

        updateHud() {
          const p = this.players[this.current];
          if (!p) return;

          if (this.playerEl) this.playerEl.textContent = String(this.current + 1);
          if (this.turnEl) this.turnEl.textContent = String(this.turnCount);
          if (this.posEl) this.posEl.textContent = String(p.pos);
          if (this.lastEl) this.lastEl.textContent = this.lastRoll == null ? "—" : String(this.lastRoll);
          if (this.pieceNameEl) this.pieceNameEl.textContent = p.name;

          if (this.finished && this.winner != null) {
            // Keep it understated.
            if (this.playerEl) this.playerEl.textContent = String(this.winner + 1);
          }
        }

        redraw() {
          this.art.draw(this.board);
          this.placePieces({ animate: false });
        }

        placePieces({ animate }) {
          const rect = this.boardEl.getBoundingClientRect();
          const inset = 14;
          const inner = {
            left: inset,
            top: inset,
            w: rect.width - inset * 2,
            h: rect.height - inset * 2,
          };

          // Group players by square for "sharing the square"
          const buckets = new Map();
          for (let i = 0; i < this.players.length; i++) {
            const pos = this.players[i].pos;
            if (!buckets.has(pos)) buckets.set(pos, []);
            buckets.get(pos).push(i);
          }

          for (const [pos, idxs] of buckets.entries()) {
            const { x, y } = coordForSquare(pos);
            const cx = inner.left + inner.w * x;
            const cy = inner.top + inner.h * y;
            const offsets = layoutOffsets(idxs.length, 12);

            idxs.forEach((playerIndex, j) => {
              const p = this.players[playerIndex];
              const off = offsets[j] || { x: 0, y: 0, s: 1 };
              p.el.style.transition = animate ? "left 180ms ease, top 180ms ease, transform 180ms ease" : "none";
              p.el.style.left = `${cx + off.x}px`;
              p.el.style.top = `${cy + off.y}px`;
              p.el.style.transform = `translate(-50%, -50%) scale(${off.s}) rotate(${(Math.random() - 0.5) * 2}deg)`;
            });
          }
        }

        async sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

        async animateWalk(player, from, to) {
          const dir = to >= from ? 1 : -1;
          const steps = Math.abs(to - from);
          for (let i = 1; i <= steps; i++) {
            player.pos = from + dir * i;
            this.placePieces({ animate: true });
            await this.sleep(85);
          }
        }

        async turn() {
          if (this.locked || this.finished) return;
          const p = this.players[this.current];
          if (!p) return;

          this.locked = true;
          this.setButtons(false);

          const roll = rollDie();
          this.lastRoll = roll;

          const who = this.players.length > 1 ? `Player ${this.current + 1}` : "You";
          this.log(`${who} rolled a ${roll}.`);
          this.updateHud();

          const target = p.pos + roll;
          if (target > 100) {
            this.log("Too much. Stay put.");
            this.locked = false;
            this.setButtons(true);
            this.advanceTurn();
            return;
          }

          const start = p.pos;
          await this.animateWalk(p, start, target);
          this.updateHud();

          // Land -> check ladder/snake (no labels, just the visuals)
          if (this.board.ladders.has(p.pos)) {
            const next = this.board.ladders.get(p.pos);
            this.log("Nice. Up you go.");
            await this.sleep(180);
            await this.animateWalk(p, p.pos, next);
          } else if (this.board.snakes.has(p.pos)) {
            const next = this.board.snakes.get(p.pos);
            this.log("Oh. That one had opinions.");
            await this.sleep(180);
            await this.animateWalk(p, p.pos, next);
          }

          this.updateHud();
          this.placePieces({ animate: true });

          if (p.pos === 100) {
            this.finished = true;
            this.winner = this.current;
            this.log(this.players.length > 1 ? `Player ${this.current + 1} made it.` : "Made it. Finally.");
            this.locked = false;
            this.setButtons(false);
            return;
          }

          this.locked = false;
          this.setButtons(true);
          this.advanceTurn();
        }

        advanceTurn() {
          if (this.players.length <= 1) {
            this.turnCount += 1;
            this.updateHud();
            return;
          }
          this.current = (this.current + 1) % this.players.length;
          this.turnCount += 1;
          this.updateHud();
        }
      }

      function showView(name) {
        const singleView = $("singleView");
        const multiView = $("multiView");
        if (name === "multiplayer") {
          singleView.classList.remove("active");
          multiView.classList.add("active");
        } else {
          multiView.classList.remove("active");
          singleView.classList.add("active");
        }
      }

      // Single player game
      const singleGame = new Game({
        boardEl: $("singleBoard"),
        gridEl: $("singleGrid"),
        canvasEl: $("singleCanvas"),
        piecesEl: $("singlePieces"),
        rollBtn: $("singleRoll"),
        newBoardBtn: $("singleNewBoard"),
        resetBtn: $("singleReset"),
        logEl: $("singleLog"),
        turnEl: $("singleTurn"),
        posEl: $("singlePos"),
        lastEl: $("singleLast"),
        pieceNameEl: $("singlePieceName"),
      });

      // Multiplayer game (created after choosing players)
      let multiGame = null;

      function startSingle() {
        singleGame.init(1);
        singleGame.setButtons(true);
      }

      function startMulti(numPlayers) {
        $("multiSetup").style.display = "none";
        $("multiStage").style.display = "flex";

        if (multiGame) multiGame.destroy();
        multiGame = new Game({
          boardEl: $("multiBoard"),
          gridEl: $("multiGrid"),
          canvasEl: $("multiCanvas"),
          piecesEl: $("multiPieces"),
          rollBtn: $("multiRoll"),
          newBoardBtn: $("multiNewBoard"),
          resetBtn: $("multiReset"),
          logEl: $("multiLog"),
          turnEl: null,
          posEl: $("multiPos"),
          lastEl: $("multiLast"),
          playerEl: $("multiPlayer"),
        });
        multiGame.init(numPlayers);
        multiGame.setButtons(true);
        multiGame.log("Alright. Be nice.");
      }

      function route() {
        const hash = (location.hash || "").toLowerCase();
        if (hash === "#multiplayer") {
          showView("multiplayer");
        } else {
          showView("single");
        }

        // Keep multiplayer page cleanly separated:
        // entering multiplayer view shows setup unless a game was started.
        if (document.getElementById("multiView").classList.contains("active")) {
          if (!$("multiStage").style.display || $("multiStage").style.display === "none") {
            $("multiSetup").style.display = "block";
            $("multiStage").style.display = "none";
          }
        }
      }

      $("choose2").addEventListener("click", () => startMulti(2));
      $("choose3").addEventListener("click", () => startMulti(3));
      window.addEventListener("hashchange", route);

      // boot
      if (!location.hash) location.hash = "#single";
      startSingle();
      route();
    </script>
  </body>
</html>
