<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LeNard’s board game</title>
    <style>
      :root {
        --outside: #0b0d10;
        --outside2: #07080a;

        --board: #5b0f14; /* deep red */
        --boardEdge: rgba(0, 0, 0, 0.24);
        --boardInnerEdge: rgba(255, 255, 255, 0.06);

        --ink: rgba(244, 241, 234, 0.92);
        --ink2: rgba(244, 241, 234, 0.7);
        --ink3: rgba(244, 241, 234, 0.5);

        --gridLine: rgba(0, 0, 0, 0.22);

        --shadow: rgba(0, 0, 0, 0.55);

        --wood: rgba(144, 98, 62, 0.92);
        --woodDark: rgba(58, 35, 18, 0.55);
        --moss: rgba(33, 120, 58, 0.55);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background:
          radial-gradient(1200px 650px at 18% 10%, rgba(120, 140, 160, 0.08), transparent 55%),
          radial-gradient(1000px 650px at 85% 18%, rgba(90, 100, 80, 0.06), transparent 55%),
          linear-gradient(180deg, var(--outside), var(--outside2));
        color: var(--ink);
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        opacity: 0.5;
        background:
          radial-gradient(circle at 25% 30%, rgba(255, 255, 255, 0.03), transparent 55%),
          radial-gradient(circle at 70% 60%, rgba(255, 255, 255, 0.02), transparent 60%),
          repeating-linear-gradient(
            112deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 9px
          );
      }

      a {
        color: inherit;
        text-decoration: underline;
        text-decoration-style: dotted;
        text-underline-offset: 4px;
      }

      .srOnly {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      .view {
        display: none;
        min-height: 100%;
      }

      .view.active {
        display: block;
      }

      .shell {
        width: min(1480px, calc(100vw - 24px));
        margin: 0 auto;
        padding: 14px 0 18px;
      }

      .title {
        font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
        font-size: 20px;
        font-weight: 500;
        letter-spacing: 0.2px;
        text-align: center;
        margin: 6px 0 14px;
        color: rgba(244, 241, 234, 0.86);
      }

      .stage {
        display: grid;
        grid-template-columns: 4fr 1fr; /* ~80% / ~20% */
        gap: 14px;
        align-items: start;
      }

      @media (max-width: 900px) {
        .stage {
          grid-template-columns: 1fr;
        }
      }

      .boardArea {
        min-width: 0;
      }

      .board {
        position: relative;
        width: 100%;
        aspect-ratio: 1 / 1;
        background: var(--board);
        border-radius: 16px;
        overflow: hidden;
        box-shadow:
          0 22px 55px var(--shadow),
          inset 0 0 0 2px var(--boardEdge),
          inset 0 0 0 7px var(--boardInnerEdge);
        transform: rotate(-0.35deg);
      }

      /* cardboard / print imperfections */
      .board::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0.92;
        background:
          radial-gradient(circle at 18% 22%, rgba(255, 255, 255, 0.06), transparent 55%),
          radial-gradient(circle at 78% 68%, rgba(0, 0, 0, 0.16), transparent 60%),
          repeating-linear-gradient(
            0deg,
            rgba(255, 255, 255, 0.02),
            rgba(255, 255, 255, 0.02) 1px,
            transparent 1px,
            transparent 7px
          ),
          repeating-linear-gradient(
            90deg,
            rgba(0, 0, 0, 0.03),
            rgba(0, 0, 0, 0.03) 1px,
            transparent 1px,
            transparent 9px
          );
        mix-blend-mode: overlay;
      }

      .board::after {
        content: "";
        position: absolute;
        inset: -1px;
        pointer-events: none;
        opacity: 0.9;
        background: radial-gradient(circle at 50% 50%, transparent 58%, rgba(0, 0, 0, 0.22) 95%);
      }

      .grid {
        position: absolute;
        inset: 14px;
        border-radius: 12px;
        overflow: hidden;
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        grid-template-rows: repeat(10, 1fr);
        box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.22);
      }

      .cell {
        position: relative;
        border-right: 1px solid var(--gridLine);
        border-bottom: 1px solid var(--gridLine);
        background:
          radial-gradient(circle at 24% 20%, rgba(255, 255, 255, 0.06), transparent 62%),
          radial-gradient(circle at 70% 78%, rgba(0, 0, 0, 0.1), transparent 65%);
      }

      .cell:nth-child(10n) {
        border-right: none;
      }

      .cell:nth-last-child(-n + 10) {
        border-bottom: none;
      }

      .cell::before {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        opacity: 0.6;
        background:
          radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.035), transparent 55%),
          radial-gradient(circle at 70% 80%, rgba(0, 0, 0, 0.06), transparent 55%);
      }

      .num {
        position: absolute;
        top: 6px;
        left: 7px;
        font-size: 9px;
        letter-spacing: 0.2px;
        color: rgba(255, 255, 255, 0.34);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        user-select: none;
        text-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
      }

      canvas.paths {
        position: absolute;
        inset: 14px;
        width: calc(100% - 28px);
        height: calc(100% - 28px);
        pointer-events: none;
      }

      .pieces {
        position: absolute;
        inset: 14px;
        pointer-events: none;
      }

      .piece {
        position: absolute;
        width: 30px;
        height: 30px;
        transform: translate(-50%, -50%);
        filter:
          drop-shadow(0 10px 16px rgba(0, 0, 0, 0.35))
          drop-shadow(0 2px 0 rgba(255, 255, 255, 0.08));
        opacity: 0.98;
      }

      .piece svg {
        width: 100%;
        height: 100%;
        display: block;
      }

      .side {
        min-width: 0;
        padding-top: 8px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        color: rgba(244, 241, 234, 0.82);
      }

      .row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(244, 241, 234, 0.14);
      }

      .row:last-child {
        border-bottom: none;
      }

      .label {
        color: rgba(244, 241, 234, 0.62);
      }

      .value {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New",
          monospace;
        color: rgba(244, 241, 234, 0.86);
      }

      .controls {
        margin-top: 10px;
        display: grid;
        gap: 8px;
      }

      button {
        appearance: none;
        background: rgba(244, 241, 234, 0.06);
        border: 1px solid rgba(244, 241, 234, 0.16);
        color: rgba(244, 241, 234, 0.88);
        padding: 10px 10px;
        border-radius: 12px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        letter-spacing: 0.2px;
        cursor: pointer;
        transition: transform 120ms ease, background 120ms ease;
      }

      button:hover {
        background: rgba(244, 241, 234, 0.1);
        transform: translateY(-1px);
      }

      button:active {
        transform: translateY(0px);
      }

      button:disabled {
        opacity: 0.55;
        cursor: not-allowed;
        transform: none;
      }

      .log {
        margin-top: 12px;
        padding-top: 8px;
        max-height: 72px;
        overflow: auto;
        color: rgba(244, 241, 234, 0.7);
      }

      .log p {
        margin: 0 0 6px 0;
      }

      .setup {
        margin: 12px auto 0;
        width: min(520px, calc(100vw - 24px));
        padding: 16px 14px;
        border: 1px solid rgba(244, 241, 234, 0.14);
        border-radius: 16px;
        background: rgba(244, 241, 234, 0.04);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        color: rgba(244, 241, 234, 0.86);
      }

      .setup h2 {
        margin: 0 0 10px 0;
        font-size: 14px;
        font-weight: 650;
      }

      .setup .choices {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <!-- metallic piece art -->
    <svg class="srOnly" aria-hidden="true">
      <defs>
        <linearGradient id="silverGrad" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="#fbfbfb" stop-opacity="0.98" />
          <stop offset="0.23" stop-color="#d7d7d7" stop-opacity="0.98" />
          <stop offset="0.52" stop-color="#bdbdbd" stop-opacity="0.98" />
          <stop offset="0.78" stop-color="#f2f2f2" stop-opacity="0.98" />
          <stop offset="1" stop-color="#9f9f9f" stop-opacity="0.98" />
        </linearGradient>
        <filter id="metalRough" x="-20%" y="-20%" width="140%" height="140%">
          <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="1" seed="11" />
          <feColorMatrix
            type="matrix"
            values="
            1 0 0 0 0
            0 1 0 0 0
            0 0 1 0 0
            0 0 0 0.16 0"
          />
          <feComposite operator="in" in2="SourceGraphic" />
          <feBlend mode="overlay" in2="SourceGraphic" />
        </filter>

        <symbol id="piece-shoe" viewBox="0 0 64 64">
          <path
            d="M10 40c6 0 10-6 14-14 3-7 7-10 12-10 4 0 6 3 8 6 2 4 4 7 9 9 4 2 7 4 7 8 0 6-6 9-16 9H18c-8 0-12-3-12-8 0-3 2-6 4-6z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M16 41c9 2 20 2 32 0"
            stroke="rgba(0,0,0,0.22)"
            stroke-width="1.2"
            stroke-linecap="round"
            opacity="0.55"
          />
        </symbol>

        <symbol id="piece-hat" viewBox="0 0 64 64">
          <path
            d="M30 10c10 10 16 22 16 30 0 7-6 10-14 10-7 0-14-3-14-10 0-9 4-18 12-30z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M10 44c8 5 36 5 44 0"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
        </symbol>

        <symbol id="piece-dog" viewBox="0 0 64 64">
          <path
            d="M18 44c0-10 7-18 16-18 7 0 12 4 14 9 3 0 6 2 6 6 0 5-4 8-9 8-1 5-6 9-13 9-9 0-14-6-14-14z"
            fill="url(#silverGrad)"
            stroke="rgba(0,0,0,0.35)"
            stroke-width="1.5"
            filter="url(#metalRough)"
          />
          <path
            d="M23 33c-3-2-6-5-6-9 0-5 5-7 9-5"
            fill="none"
            stroke="rgba(0,0,0,0.24)"
            stroke-width="1.3"
            stroke-linecap="round"
            opacity="0.6"
          />
        </symbol>
      </defs>
    </svg>

    <section class="view active" id="view-single" aria-label="Single player">
      <div class="shell">
        <div class="title">LeNard’s board game</div>
        <div class="stage">
          <div class="boardArea">
            <div class="board" id="single-board">
              <canvas class="paths" id="single-canvas" width="1000" height="1000" aria-hidden="true"></canvas>
              <div class="grid" id="single-grid" aria-hidden="true"></div>
              <div class="pieces" id="single-pieces" aria-hidden="true"></div>
            </div>
          </div>
          <aside class="side" aria-label="Controls">
            <div class="row">
              <div class="label">Turn</div>
              <div class="value" id="single-turn">1</div>
            </div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="single-pos">1</div>
            </div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="single-last">—</div>
            </div>
            <div class="row">
              <div class="label">Piece</div>
              <div class="value" id="single-piece">—</div>
            </div>
            <div class="controls">
              <button id="single-roll" type="button">Roll</button>
              <button id="single-new" type="button">New board</button>
              <button id="single-reset" type="button">Reset</button>
            </div>
            <div style="margin-top: 10px; color: rgba(244, 241, 234, 0.62)">
              <a href="#multiplayer">Multiplayer</a>
            </div>
            <div class="log" id="single-log" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

    <section class="view" id="view-multi" aria-label="Multiplayer">
      <div class="shell">
        <div class="title">LeNard’s board game</div>

        <div class="setup" id="multi-setup">
          <h2>Multiplayer</h2>
          <div class="choices" role="group" aria-label="Choose number of players">
            <button id="multi-2" type="button">2 players</button>
            <button id="multi-3" type="button">3 players</button>
          </div>
          <div style="margin-top: 10px; color: rgba(244, 241, 234, 0.62)">
            <a href="#single">Back to single-player</a>
          </div>
        </div>

        <div class="stage" id="multi-stage" style="display: none">
          <div class="boardArea">
            <div class="board" id="multi-board">
              <canvas class="paths" id="multi-canvas" width="1000" height="1000" aria-hidden="true"></canvas>
              <div class="grid" id="multi-grid" aria-hidden="true"></div>
              <div class="pieces" id="multi-pieces" aria-hidden="true"></div>
            </div>
          </div>
          <aside class="side" aria-label="Controls">
            <div class="row">
              <div class="label">Player</div>
              <div class="value" id="multi-player">1</div>
            </div>
            <div class="row">
              <div class="label">On</div>
              <div class="value" id="multi-pos">1</div>
            </div>
            <div class="row">
              <div class="label">Last</div>
              <div class="value" id="multi-last">—</div>
            </div>
            <div class="controls">
              <button id="multi-roll" type="button">Roll</button>
              <button id="multi-new" type="button">New board</button>
              <button id="multi-reset" type="button">Reset</button>
            </div>
            <div style="margin-top: 10px; color: rgba(244, 241, 234, 0.62)">
              <a href="#single">Single-player</a>
            </div>
            <div class="log" id="multi-log" aria-live="polite"></div>
          </aside>
        </div>
      </div>
    </section>

    <script>
      const $ = (id) => document.getElementById(id);

      function randInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      function clamp(n, a, b) {
        return Math.max(a, Math.min(b, n));
      }

      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function mulberry32(seed) {
        let t = seed >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let r = Math.imul(t ^ (t >>> 15), 1 | t);
          r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
          return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
        };
      }

      function seedPair(a, b) {
        return ((a * 73856093) ^ (b * 19349663) ^ 0x9e3779b9) >>> 0;
      }

      function coordForSquare(n) {
        // Serpentine numbering: bottom row 1..10 left->right, next row right->left...
        const idx = n - 1;
        const row = Math.floor(idx / 10); // 0..9 bottom->top
        const colInRow = idx % 10;
        const rev = row % 2 === 1;
        const col = rev ? 9 - colInRow : colInRow;
        return { x: (col + 0.5) / 10, y: 1 - (row + 0.5) / 10 };
      }

      function buildGrid(gridEl) {
        gridEl.innerHTML = "";
        for (let visualRow = 9; visualRow >= 0; visualRow--) {
          for (let visualCol = 0; visualCol < 10; visualCol++) {
            const logicalRow = 9 - visualRow;
            const rev = logicalRow % 2 === 1;
            const colInRow = rev ? 9 - visualCol : visualCol;
            const n = logicalRow * 10 + colInRow + 1;

            const cell = document.createElement("div");
            cell.className = "cell";
            const num = document.createElement("div");
            num.className = "num";
            num.textContent = String(n);
            cell.appendChild(num);
            gridEl.appendChild(cell);
          }
        }
      }

      function offsetsForCount(count, radius) {
        if (count <= 1) return [{ x: 0, y: 0, s: 1 }];
        if (count === 2) {
          return [
            { x: -radius * 0.75, y: 0, s: 0.88 },
            { x: radius * 0.75, y: radius * 0.1, s: 0.88 },
          ];
        }
        return [
          { x: -radius * 0.65, y: radius * 0.35, s: 0.82 },
          { x: radius * 0.7, y: radius * 0.25, s: 0.82 },
          { x: radius * 0.05, y: -radius * 0.65, s: 0.82 },
        ];
      }

      function createPiece(symbolId, label) {
        const el = document.createElement("div");
        el.className = "piece";
        // href works in modern browsers; xlink:href helps older ones.
        el.innerHTML = `
          <svg viewBox="0 0 64 64" role="img" aria-label="${label}">
            <use href="#${symbolId}" xlink:href="#${symbolId}"></use>
          </svg>
        `;
        return el;
      }

      class BoardRenderer {
        constructor(boardEl, canvasEl) {
          this.boardEl = boardEl;
          this.canvasEl = canvasEl;
        }

        resizeCanvas() {
          const rect = this.boardEl.getBoundingClientRect();
          const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
          this.canvasEl.width = Math.floor(rect.width * dpr);
          this.canvasEl.height = Math.floor(rect.height * dpr);
          const ctx = this.canvasEl.getContext("2d");
          if (!ctx) return null;
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          return { ctx, rect };
        }

        squareToPx(n, rect) {
          const inset = 14;
          const inner = {
            left: inset,
            top: inset,
            w: rect.width - inset * 2,
            h: rect.height - inset * 2,
          };
          const { x, y } = coordForSquare(n);
          return { x: inner.left + inner.w * x, y: inner.top + inner.h * y };
        }

        draw(boardMap) {
          const res = this.resizeCanvas();
          if (!res) return;
          const { ctx, rect } = res;
          ctx.clearRect(0, 0, rect.width, rect.height);

          // subtle smudges
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.fillStyle = "rgba(0,0,0,0.22)";
          for (let i = 0; i < 14; i++) {
            const x = Math.random() * rect.width;
            const y = Math.random() * rect.height;
            const r = 16 + Math.random() * 28;
            ctx.beginPath();
            ctx.ellipse(x, y, r * 1.2, r, (Math.random() - 0.5) * 0.6, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();

          // ladders under snakes
          for (const [from, to] of boardMap.ladders.entries()) this.drawLadder(ctx, rect, from, to);
          for (const [from, to] of boardMap.snakes.entries()) this.drawSnake(ctx, rect, from, to);
        }

        drawLadder(ctx, rect, from, to) {
          const rnd = mulberry32(seedPair(from, to) ^ 0x8f2a);
          const a = this.squareToPx(from, rect);
          const b = this.squareToPx(to, rect);
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy) || 1;
          const dir = { x: dx / len, y: dy / len };
          const nrm = { x: -dir.y, y: dir.x };

          const rail = clamp(10 + rnd() * 6, 10, 16);
          const railW = clamp(4.5 + rnd() * 2.0, 4.5, 7.4);

          const wood = getComputedStyle(document.documentElement).getPropertyValue("--wood").trim() || "rgba(144, 98, 62, 0.92)";
          const woodDark =
            getComputedStyle(document.documentElement).getPropertyValue("--woodDark").trim() || "rgba(58, 35, 18, 0.55)";
          const moss = getComputedStyle(document.documentElement).getPropertyValue("--moss").trim() || "rgba(33, 120, 58, 0.55)";

          const jitter = (t) => (rnd() - 0.5) * t;

          // rails
          for (const side of [-1, 1]) {
            const ox = nrm.x * rail * side;
            const oy = nrm.y * rail * side;
            const mid = {
              x: (a.x + b.x) / 2 + nrm.x * (rnd() - 0.5) * 18,
              y: (a.y + b.y) / 2 + nrm.y * (rnd() - 0.5) * 18,
            };

            ctx.save();
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.shadowColor = "rgba(0,0,0,0.25)";
            ctx.shadowBlur = 10;
            ctx.lineWidth = railW;
            ctx.strokeStyle = wood;
            ctx.beginPath();
            ctx.moveTo(a.x + ox + jitter(0.8), a.y + oy + jitter(0.8));
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox + jitter(0.8), b.y + oy + jitter(0.8));
            ctx.stroke();

            // grain line
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.55;
            ctx.strokeStyle = woodDark;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(a.x + ox, a.y + oy);
            ctx.quadraticCurveTo(mid.x + ox, mid.y + oy, b.x + ox, b.y + oy);
            ctx.stroke();
            ctx.restore();
          }

          // rungs
          const rungCount = clamp(Math.floor(len / 48) + 2, 4, 9);
          for (let i = 1; i <= rungCount; i++) {
            const t = i / (rungCount + 1);
            const px = a.x + dx * t + jitter(2.2);
            const py = a.y + dy * t + jitter(2.2);

            ctx.save();
            ctx.lineCap = "round";
            ctx.shadowColor = "rgba(0,0,0,0.24)";
            ctx.shadowBlur = 8;
            ctx.lineWidth = clamp(3.8 + rnd() * 1.2, 3.8, 5.4);
            ctx.strokeStyle = wood;
            ctx.beginPath();
            ctx.moveTo(px - nrm.x * rail + jitter(0.9), py - nrm.y * rail + jitter(0.9));
            ctx.lineTo(px + nrm.x * rail + jitter(0.9), py + nrm.y * rail + jitter(0.9));
            ctx.stroke();

            // cracks
            ctx.shadowBlur = 0;
            ctx.globalAlpha = 0.6;
            ctx.strokeStyle = "rgba(40, 24, 12, 0.45)";
            ctx.lineWidth = 1;
            const crackN = 1 + Math.floor(rnd() * 3);
            for (let c = 0; c < crackN; c++) {
              const cx = px + (rnd() - 0.5) * 10;
              const cy = py + (rnd() - 0.5) * 6;
              ctx.beginPath();
              ctx.moveTo(cx, cy);
              ctx.lineTo(cx + (rnd() - 0.5) * 10, cy + (rnd() - 0.5) * 10);
              ctx.stroke();
            }

            // moss
            ctx.globalAlpha = 0.85;
            ctx.fillStyle = moss;
            const mossN = Math.floor(rnd() * 4);
            for (let m = 0; m < mossN; m++) {
              const mx = px + (rnd() - 0.5) * 18;
              const my = py + (rnd() - 0.5) * 10;
              ctx.beginPath();
              ctx.arc(mx, my, 1 + rnd() * 2.2, 0, Math.PI * 2);
              ctx.fill();
            }

            ctx.restore();
          }
        }

        drawSnake(ctx, rect, from, to) {
          // black mamba-ish: tapered ribbon + shine + wedge head
          const rnd = mulberry32(seedPair(from, to) ^ 0x33c9);
          const a = this.squareToPx(from, rect);
          const b = this.squareToPx(to, rect);
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const len = Math.hypot(dx, dy) || 1;
          const dir = { x: dx / len, y: dy / len };
          const nrm = { x: -dir.y, y: dir.x };

          const steps = clamp(Math.floor(len / 16), 18, 60);
          const baseW = clamp(10 + rnd() * 6, 10, 18);
          const wiggle = clamp(10 + rnd() * 12, 10, 20);
          const phase = rnd() * Math.PI * 2;
          const freq = 2.1 + rnd() * 1.6;

          const pts = [];
          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const ease = t * t * (3 - 2 * t);
            const px = a.x + dx * ease;
            const py = a.y + dy * ease;
            const w =
              Math.sin(phase + t * Math.PI * 2 * freq) *
              wiggle *
              (0.25 + 0.75 * Math.sin(Math.PI * t));
            const j = (rnd() - 0.5) * 0.9;
            pts.push({ x: px + nrm.x * w + j, y: py + nrm.y * w - j, t });
          }

          const left = [];
          const right = [];
          for (let i = 0; i < pts.length; i++) {
            const p = pts[i];
            const p0 = pts[Math.max(0, i - 1)];
            const p1 = pts[Math.min(pts.length - 1, i + 1)];
            const vx = p1.x - p0.x;
            const vy = p1.y - p0.y;
            const vlen = Math.hypot(vx, vy) || 1;
            const nx = -vy / vlen;
            const ny = vx / vlen;
            const taper = 0.18 + 0.82 * Math.sin(Math.PI * p.t);
            const width = baseW * taper * (0.92 + (rnd() - 0.5) * 0.08);
            left.push({ x: p.x + nx * width, y: p.y + ny * width, t: p.t });
            right.push({ x: p.x - nx * width, y: p.y - ny * width, t: p.t });
          }

          ctx.save();
          ctx.shadowColor = "rgba(0,0,0,0.38)";
          ctx.shadowBlur = 18;
          ctx.fillStyle = "rgba(10,10,10,0.92)";
          ctx.beginPath();
          ctx.moveTo(left[0].x, left[0].y);
          for (let i = 1; i < left.length; i++) ctx.lineTo(left[i].x, left[i].y);
          for (let i = right.length - 1; i >= 0; i--) ctx.lineTo(right[i].x, right[i].y);
          ctx.closePath();
          ctx.fill();

          // shine
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.35;
          ctx.strokeStyle = "rgba(255,255,255,0.22)";
          ctx.lineWidth = 2.2;
          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.beginPath();
          const s0 = Math.floor(pts.length * 0.12);
          const s1 = Math.floor(pts.length * 0.85);
          for (let i = s0; i <= s1; i++) {
            const p = pts[i];
            const off = 2 + Math.sin(phase + p.t * 9) * 1.2;
            if (i === s0) ctx.moveTo(p.x + off, p.y - off);
            else ctx.lineTo(p.x + off, p.y - off);
          }
          ctx.stroke();

          // head wedge at "from"
          const head = pts[0];
          const neck = pts[2] || pts[1] || head;
          const hvx = head.x - neck.x;
          const hvy = head.y - neck.y;
          const hvlen = Math.hypot(hvx, hvy) || 1;
          const fx = hvx / hvlen;
          const fy = hvy / hvlen;
          const px = -fy;
          const py = fx;
          const headL = clamp(16 + rnd() * 8, 16, 24);
          const headW = clamp(10 + rnd() * 6, 10, 16);

          ctx.globalAlpha = 0.95;
          ctx.fillStyle = "rgba(12,12,12,0.96)";
          ctx.beginPath();
          ctx.moveTo(head.x + fx * headL, head.y + fy * headL);
          ctx.lineTo(head.x + px * headW, head.y + py * headW);
          ctx.lineTo(head.x - px * headW, head.y - py * headW);
          ctx.closePath();
          ctx.fill();

          // tiny eye glint
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = "rgba(255,255,255,0.35)";
          ctx.beginPath();
          ctx.arc(head.x + fx * (headL * 0.55) + px * 2.2, head.y + fy * (headL * 0.55) + py * 2.2, 1.2, 0, Math.PI * 2);
          ctx.fill();

          ctx.restore();
        }
      }

      class Game {
        constructor(opts) {
          this.boardEl = opts.boardEl;
          this.canvasEl = opts.canvasEl;
          this.gridEl = opts.gridEl;
          this.piecesEl = opts.piecesEl;
          this.rollBtn = opts.rollBtn;
          this.newBtn = opts.newBtn;
          this.resetBtn = opts.resetBtn;
          this.logEl = opts.logEl;
          this.hud = opts.hud;

          this.renderer = new BoardRenderer(this.boardEl, this.canvasEl);

          this.board = { snakes: new Map(), ladders: new Map() };
          this.players = [];
          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;

          this._onResize = () => this.redraw();
        }

        init(playerCount) {
          buildGrid(this.gridEl);
          this.newBoard();
          this.startPlayers(playerCount);
          this.bind();
          this.redraw();
          this.log("All set. Try your luck.");
          this.setButtons(true);
        }

        bind() {
          this.rollBtn.addEventListener("click", () => this.takeTurn());
          this.newBtn.addEventListener("click", () => this.reset(true));
          this.resetBtn.addEventListener("click", () => this.reset(false));
          window.addEventListener("resize", this._onResize);

          window.addEventListener("keydown", (e) => {
            const activeView = document.querySelector(".view.active");
            if (!activeView || !activeView.contains(this.boardEl)) return;
            if (e.key === " " || e.key === "Spacebar") {
              e.preventDefault();
              this.takeTurn();
            } else if (e.key === "r" || e.key === "R") {
              e.preventDefault();
              this.reset(false);
            }
          });
        }

        destroy() {
          window.removeEventListener("resize", this._onResize);
        }

        setButtons(enabled) {
          this.rollBtn.disabled = !enabled;
          this.newBtn.disabled = !enabled;
          this.resetBtn.disabled = !enabled;
        }

        log(text) {
          const p = document.createElement("p");
          p.textContent = text;
          this.logEl.prepend(p);
          while (this.logEl.childElementCount > 14) this.logEl.removeChild(this.logEl.lastElementChild);
        }

        clearLog() {
          this.logEl.innerHTML = "";
        }

        hasEndpointCollision(map, start, end) {
          for (const [a, b] of map.entries()) {
            if (a === start || a === end || b === start || b === end) return true;
          }
          return false;
        }

        newBoard() {
          this.board.snakes.clear();
          this.board.ladders.clear();
          const used = new Set([1, 100]);

          const ladderTarget = 7;
          const snakeTarget = 7;

          const canUse = (x) => x >= 2 && x <= 99 && !used.has(x);

          const addPair = (kind) => {
            for (let tries = 0; tries < 3000; tries++) {
              let from, to;
              if (kind === "ladder") {
                from = randInt(2, 75);
                to = randInt(from + 12, Math.min(99, from + 38));
              } else {
                from = randInt(18, 99);
                to = randInt(Math.max(2, from - 38), from - 12);
              }
              if (!canUse(from) || !canUse(to)) continue;
              if (this.board.ladders.has(from) || this.board.snakes.has(from)) continue;
              if (this.board.ladders.has(to) || this.board.snakes.has(to)) continue;
              if (this.hasEndpointCollision(this.board.ladders, from, to)) continue;
              if (this.hasEndpointCollision(this.board.snakes, from, to)) continue;
              const dist = Math.abs(to - from);
              if (dist < 12 || dist > 42) continue;
              if (kind === "ladder") this.board.ladders.set(from, to);
              else this.board.snakes.set(from, to);
              used.add(from);
              used.add(to);
              return true;
            }
            return false;
          };

          while (this.board.ladders.size < ladderTarget) if (!addPair("ladder")) break;
          while (this.board.snakes.size < snakeTarget) if (!addPair("snake")) break;
        }

        startPlayers(n) {
          this.players = [];
          this.piecesEl.innerHTML = "";

          const pool = shuffle([
            { sym: "piece-shoe", name: "shoe" },
            { sym: "piece-hat", name: "wizard hat" },
            { sym: "piece-dog", name: "dog" },
          ]);
          const chosen = pool.slice(0, n);

          for (let i = 0; i < n; i++) {
            const s = chosen[i];
            const el = createPiece(s.sym, s.name);
            this.piecesEl.appendChild(el);
            this.players.push({ pos: 1, name: s.name, el });
          }

          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;
          this.updateHud();
          this.placePieces(false);
        }

        reset(newBoard) {
          this.setButtons(false);
          this.clearLog();
          if (newBoard) this.newBoard();
          for (const p of this.players) p.pos = 1;
          this.current = 0;
          this.turn = 1;
          this.last = null;
          this.locked = false;
          this.finished = false;
          this.winner = null;
          this.redraw();
          this.placePieces(false);
          this.updateHud();
          this.log(newBoard ? "Fresh board. Same bad luck." : "Back to square one.");
          this.setButtons(true);
        }

        redraw() {
          this.renderer.draw(this.board);
          this.placePieces(false);
        }

        updateHud() {
          const p = this.players[this.current];
          if (!p) return;
          if (this.hud.player) this.hud.player.textContent = String(this.current + 1);
          if (this.hud.turn) this.hud.turn.textContent = String(this.turn);
          if (this.hud.pos) this.hud.pos.textContent = String(p.pos);
          if (this.hud.last) this.hud.last.textContent = this.last == null ? "—" : String(this.last);
          if (this.hud.piece) this.hud.piece.textContent = p.name;
        }

        placePieces(animate) {
          const rect = this.boardEl.getBoundingClientRect();
          const inset = 14;
          const inner = { left: inset, top: inset, w: rect.width - inset * 2, h: rect.height - inset * 2 };

          const buckets = new Map();
          for (let i = 0; i < this.players.length; i++) {
            const pos = this.players[i].pos;
            if (!buckets.has(pos)) buckets.set(pos, []);
            buckets.get(pos).push(i);
          }

          for (const [pos, idxs] of buckets.entries()) {
            const { x, y } = coordForSquare(pos);
            const cx = inner.left + inner.w * x;
            const cy = inner.top + inner.h * y;
            const base = offsetsForCount(idxs.length, 12);

            idxs.forEach((pi, j) => {
              const pl = this.players[pi];
              const off = base[j] || { x: 0, y: 0, s: 1 };
              const jx = (Math.random() - 0.5) * 1.2;
              const jy = (Math.random() - 0.5) * 1.2;
              const rot = (Math.random() - 0.5) * 2;
              pl.el.style.transition = animate ? "left 180ms ease, top 180ms ease, transform 180ms ease" : "none";
              pl.el.style.left = `${cx + off.x + jx}px`;
              pl.el.style.top = `${cy + off.y + jy}px`;
              pl.el.style.transform = `translate(-50%, -50%) scale(${off.s}) rotate(${rot}deg)`;
            });
          }
        }

        sleep(ms) {
          return new Promise((r) => setTimeout(r, ms));
        }

        async walk(pl, from, to) {
          const dir = to >= from ? 1 : -1;
          const steps = Math.abs(to - from);
          for (let i = 1; i <= steps; i++) {
            pl.pos = from + dir * i;
            this.placePieces(true);
            await this.sleep(85);
          }
        }

        async applyTransitions(pl) {
          // apply snake/ladder repeatedly, but guard against loops.
          const seen = new Set();
          while (true) {
            if (seen.has(pl.pos)) break;
            seen.add(pl.pos);
            if (this.board.ladders.has(pl.pos)) {
              const next = this.board.ladders.get(pl.pos);
              this.log("Nice. Up you go.");
              await this.sleep(180);
              await this.walk(pl, pl.pos, next);
              continue;
            }
            if (this.board.snakes.has(pl.pos)) {
              const next = this.board.snakes.get(pl.pos);
              this.log("Oh. That one had opinions.");
              await this.sleep(180);
              await this.walk(pl, pl.pos, next);
              continue;
            }
            break;
          }
        }

        async takeTurn() {
          if (this.locked || this.finished) return;
          const pl = this.players[this.current];
          if (!pl) return;

          this.locked = true;
          this.setButtons(false);

          const roll = randInt(1, 6);
          this.last = roll;
          const who = this.players.length > 1 ? `Player ${this.current + 1}` : "You";
          this.log(`${who} rolled a ${roll}.`);
          this.updateHud();

          const target = pl.pos + roll;
          if (target > 100) {
            this.log("Too much. Stay put.");
            this.locked = false;
            this.setButtons(true);
            this.advance();
            return;
          }

          const start = pl.pos;
          await this.walk(pl, start, target);
          await this.applyTransitions(pl);

          this.updateHud();
          this.placePieces(true);

          if (pl.pos === 100) {
            this.finished = true;
            this.winner = this.current;
            this.log(this.players.length > 1 ? `Player ${this.current + 1} made it.` : "Made it. Finally.");
            this.locked = false;
            this.setButtons(false);
            return;
          }

          this.locked = false;
          this.setButtons(true);
          this.advance();
        }

        advance() {
          if (this.players.length <= 1) {
            this.turn += 1;
            this.updateHud();
            return;
          }
          this.current = (this.current + 1) % this.players.length;
          this.turn += 1;
          this.updateHud();
        }
      }

      function showView(which) {
        $("view-single").classList.toggle("active", which === "single");
        $("view-multi").classList.toggle("active", which === "multi");
      }

      // Single player instance
      const singleGame = new Game({
        boardEl: $("single-board"),
        canvasEl: $("single-canvas"),
        gridEl: $("single-grid"),
        piecesEl: $("single-pieces"),
        rollBtn: $("single-roll"),
        newBtn: $("single-new"),
        resetBtn: $("single-reset"),
        logEl: $("single-log"),
        hud: {
          turn: $("single-turn"),
          pos: $("single-pos"),
          last: $("single-last"),
          piece: $("single-piece"),
          player: null,
        },
      });

      let multiGame = null;

      function startMulti(n) {
        $("multi-setup").style.display = "none";
        $("multi-stage").style.display = "grid";
        if (multiGame) multiGame.destroy();
        multiGame = new Game({
          boardEl: $("multi-board"),
          canvasEl: $("multi-canvas"),
          gridEl: $("multi-grid"),
          piecesEl: $("multi-pieces"),
          rollBtn: $("multi-roll"),
          newBtn: $("multi-new"),
          resetBtn: $("multi-reset"),
          logEl: $("multi-log"),
          hud: {
            player: $("multi-player"),
            pos: $("multi-pos"),
            last: $("multi-last"),
            turn: null,
            piece: null,
          },
        });
        multiGame.init(n);
        multiGame.log("Alright. Be nice.");
      }

      $("multi-2").addEventListener("click", () => startMulti(2));
      $("multi-3").addEventListener("click", () => startMulti(3));

      function route() {
        const h = (location.hash || "").toLowerCase();
        if (h === "#multiplayer") {
          showView("multi");
          if (!$("multi-stage").style.display || $("multi-stage").style.display === "none") {
            $("multi-setup").style.display = "block";
            $("multi-stage").style.display = "none";
          }
        } else {
          showView("single");
        }
      }

      window.addEventListener("hashchange", route);

      // boot
      if (!location.hash) location.hash = "#single";
      singleGame.init(1);
      route();
    </script>
  </body>
</html>
